<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>オンライン神経衰弱</title>
    <style>
        .game-board {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 8px;
            padding: 10px;
        }

        .card {
            aspect-ratio: 5 / 7;
            width: 100%;
            border: 2px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: black;
            cursor: pointer;
        }

        #playerList li {
            font-size: 20px;
            /* プレイヤーネームの文字サイズを大きくする */
            font-weight: bold;
            /* 太字にする */
            margin-bottom: 10px;
        }

        #buttonContainer {
            display: flex;
            gap: 10px;
            /* ボタン間のスペース */
            justify-content: center;
            /* ボタンを中央揃え */
            margin-top: 30px;
            /* 上部に余白を追加 */
        }

        #startGameBtn,
        #cardsBtn,
        #retireGameBtn {
            font-size: 18px;
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
        }

        #startGameBtn {
            background-color: #4CAF50;
            color: white;
        }

        #cardsBtn {
            background-color: #2196F3;
            color: white;
        }

        #retireGameBtn {
            background-color: #f44336;
            color: white;
        }



        #startGameBtn:disabled,
        #cardsBtn:disabled,
        #retireGameBtn:disabled {
            background-color: #aaa;
            cursor: not-allowed;
        }



        .flipped {
            background-color: white;
        }

        .score-board {
            margin-top: 20px;
            text-align: center;
            font-size: 20px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
        }

        .effect-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.3s ease;
        }

        .effect-modal img {
            width: 200px;
            height: auto;
            margin-bottom: 20px;
        }

        .effect-modal.hidden {
            display: none;
        }

        #effectText {
            font-size: 32px;
            /* 文字を大きく */
            color: #00aaff;
            /* 青系のカラーに */
            text-align: center;
            /* 中央揃え */
            font-weight: bold;
            /* 太字にして見やすく */
            margin-top: 10px;
            /* 画像との余白 */
        }

        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .start-menu {
            text-align: center;
            margin-top: 50px;
        }




        #gameBoard,
        .score-board,
        .current-Player {
            display: none;
        }

        .highlight-red {
            border: 3px solid red;
            box-shadow: 0 0 10px red;
            transition: all 0.3s;
        }

        .card-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 16px;
            justify-items: center;
            margin-top: 20px;
        }

        .card-wrapper {
            width: 100%;
            max-width: 150px;
            text-align: center;
        }

        .card-wrapper img {
            width: 100%;
            height: auto;
            object-fit: contain;
        }

        .card-wrapper label,
        .card-wrapper input {
            display: block;
            margin-top: 8px;
        }

        /* ボタンスタイル */
        #cardSelectionForm button {
            margin-top: 30px;
            padding: 12px 24px;
            font-size: 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s;
            width: 80%;
            max-width: 300px;
        }

        #cardSelectionForm button:hover {
            background-color: #45a049;
        }

        /* スマホ画面用の調整 */
        @media (max-width: 600px) {
            .card-container {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            }

            #cardSelectionForm button {
                font-size: 18px;
                padding: 10px 20px;
                width: 90%;
            }
        }


        /* もう一度プレイボタン */
        #restartButton {
            background: linear-gradient(45deg, #6e7e80, #4c5c63);
            /* グラデーション */
            color: white;
            padding: 15px 30px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            /* 丸い角 */
            cursor: pointer;
            transition: transform 0.2s, background-color 0.3s ease;
            /* アニメーション */
            box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.2);
            /* シャドウ */
        }

        /* 終了ボタン */
        #exitButton {
            background: linear-gradient(45deg, #f44336, #ff9800);
            /* 赤オレンジのグラデーション */
            color: white;
            padding: 15px 30px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            /* 丸い角 */
            cursor: pointer;
            transition: transform 0.2s, background-color 0.3s ease;
            /* アニメーション */
            box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.2);
            /* シャドウ */
        }

        /* ホバー時に色を変更 */
        #restartButton:hover {
            background: linear-gradient(45deg, #5a6b74, #3f4f57);
            /* 少し濃い色 */
            transform: translateY(-4px);
            /* 上に浮かせる */
        }

        #exitButton:hover {
            background: linear-gradient(45deg, #e53935, #f57c00);
            /* 終了ボタンの色変更 */
            transform: translateY(-4px);
            /* 上に浮かせる */
        }

        /* クリック時に少し縮む */
        button:active {
            transform: scale(0.98);
        }

        /* confirmCardBtn のみに適用 */
        #startGameBtn:disabled {
            cursor: not-allowed;
            /* 禁止カーソル */
            background-color: #ccc;
            /* ボタンの背景色を変更 */
            color: #666;
            /* ボタンの文字色を変更 */
            border: 1px solid #999;
            /* 枠線を変更 */
        }

        /* ボタンが無効になったとき、マウスオーバー時にカーソルを禁止に変更 */
        /* confirmCardBtn のみに適用 */
        #confirmCardBtn:disabled {
            cursor: not-allowed;
            /* 禁止カーソル */
            background-color: #ccc;
            /* ボタンの背景色を変更 */
            color: #666;
            /* ボタンの文字色を変更 */
            border: 1px solid #999;
            /* 枠線を変更 */
        }
    </style>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
</head>

<body>

    <!-- ゲーム参加画面 -->
    <div id="joinGameSection">
        <h2>ゲームに参加</h2>
        <input type="text" id="gameIdInput" placeholder="ゲームIDを入力">
        <button onclick="joinGame()">次へ</button>
    </div>

    <!-- 名前入力 -->
    <div id="nameInputSection" style="display:none;">
        <h2>プレイヤー名を入力</h2>
        <input type="text" id="playerNameInput" placeholder="名前">
        <button onclick="enterLobby()">ロビーに参加</button>
    </div>

    <!-- ロビー -->
    <div id="lobbySection" style="display:none;">
        <h2>待機中のプレイヤー</h2>
        <ul id="playerList"></ul>
        <button id="startGameBtn" onclick="startGameInLobby()" disabled>ゲーム開始</button>
        <button id="cardsBtn" onclick="requestCardSelection()">カード選択</button>
        <button id="retireGameBtn" onclick="leaveGame()">抜ける</button>
    </div>
    <div id="gameIdDisplay" style="margin-top: 10px; font-size: 18px; font-weight: bold;"></div>



    <!-- ゲーム画面 -->
    <div class="current-Player">
        <div id="currentPlayer"></div>
    </div>
    <div class="game-board" id="gameBoard"></div>
    <div class="score-board">
        <div id="scores"></div>
    </div>
    <div id="gameOverModal" class="modal">
        <div class="modal-content">
            <h2>ゲーム終了！</h2>
            <p id="finalScore"></p>
            <button id="restartButton" onclick="restartGame()">もう一度プレイ</button>
            <button id="exitButton" onclick="leaveGame()">終了</button>

        </div>
    </div>
    <div id="effectModal" class="effect-modal hidden">
        <img id="effectImage" src="" alt="Card Image" />
        <div id="effectText"></div>
    </div>
    <div id="cardSelectionSection" style="display: none;">
        <h3>カードを選択してください</h3>
        <form id="cardSelectionForm" onsubmit="return false;">
            <div id="cardSelectionContainer" class="card-container"></div>
            <button id="confirmCardBtn" onclick="backlobby()" disabled>カードを決定</button>
        </form>
    </div>




    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyBvjSDUh-IaCZQ17bE3Q4IfI0yZDqbDcz0",
            authDomain: "flipcards-5ca31.firebaseapp.com",
            projectId: "flipcards-5ca31",
            storageBucket: "flipcards-5ca31.appspot.com",
            messagingSenderId: "599139871804",
            appId: "1:599139871804:web:5402c51a0acfd75cd36739",
            measurementId: "G-KB8ZCG0HG8"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        let gameId = "";
        let playerName = "";
        let myplayerName = "";
        let currentPlayer = 1;
        let PName = {};
        let numPlayers = 0;
        let playerId = "";
        let skipdata = 0;
        let generatedCards = [];
        let cards = [];
        let selectedCards = [];
        let cardImages = {
            "bomb": "bomb.png",
            "special": "special.png",
            "skip": "skip.png",
            "devil": "devil.png",
            "angel": "angel.png",
            "thief": "thief.png",
            "king": "king.png",
            "revo": "revo.png",
            "heart": "heart.png",
            "crowbar": "crowbar.png",
            "diamond": "diamond.png",
            "spade": "spade.png",
            "karaage": "karaage.png",
            "elf": "elf.png",
            "1": "1.png",
            "2": "2.png",
            "3": "3.png",
        };
        let isThiefMode = false;        // 泥棒効果中かどうか
        let resolveThiefSelect = null;
        let selectedThiefIndex = null;
        const specialTypes = ["heart", "crowbar", "diamond", "spade"];
        const originalCardImages = {
            heart: "heart.png",
            crowbar: "crowbar.png",
            diamond: "diamond.png",
            spade: "spade.png",
        };
        let lastEffectTimestamp = 0;
        let selectedspecialIndex = null;
        let originalSpecialCards = []; // 元の状態保存用
        let isKaraageMode = false;
        let karaageEffect = false;
        let finishkaraageEffect = false;
        let scores = {};
        let flippedCards = [];
        let lastSeenEffectKey = "";

        async function checkIfHost() {
            const playerDoc = await db.collection("games")
                .doc(gameId)
                .collection("players")
                .doc(playerId)
                .get();

            const data = playerDoc.data();
            if (data && data.isHost) {
                document.getElementById("startGameBtn").disabled = false;
                document.getElementById("confirmCardBtn").disabled = false;
            } else {
                document.getElementById("startGameBtn").disabled = true;
                document.getElementById("confirmCardBtn").disabled = true;
            }
        }



        function joinGame() {
            gameId = document.getElementById("gameIdInput").value.trim();
            if (!gameId) return alert("ゲームIDを入力してください");
            document.getElementById("joinGameSection").style.display = "none";
            document.getElementById("nameInputSection").style.display = "block";
        }

        async function enterLobby() {
            playerName = document.getElementById("playerNameInput").value.trim();
            if (!playerName) return alert("名前を入力してください");

            const gameRef = db.collection("games").doc(gameId);
            const playersRef = gameRef.collection("players");

            const gameSnap = await gameRef.get();
            const gameData = gameSnap.data();

            // ゲームドキュメントを作成・更新（started フラグは初期 false）
            if (!gameData || gameData.started === undefined) {
                await gameRef.set({ started: false }, { merge: true });
            }

            // 同じ名前のプレイヤーがすでに存在するか確認（復帰対応）
            const snapshot = await playersRef.where("name", "==", playerName).get();

            if (!snapshot.empty) {
                // 再接続: 既存プレイヤーとして playerId を取得
                playerId = snapshot.docs[0].id;
            } else {
                // 新規プレイヤー作成
                playerId = `player_${Date.now()}`;
                const allPlayersSnap = await playersRef.get();
                isHost = allPlayersSnap.empty;

                await playersRef.doc(playerId).set({
                    name: playerName,
                    isHost: isHost
                });

                if (isHost) {
                    await updateHostStatus();
                }
            }

            await checkIfHost();
            listenToCardSelectionStatus();
            listenToLobby(); // ロビー表示・更新

            // 🔥 ここでゲームが始まっていたら、即ゲーム画面に復帰
            if (gameData && gameData.started) {

                // 復帰：ゲーム画面へ移行
                document.getElementById("nameInputSection").style.display = "none";
                document.getElementById("lobbySection").style.display = "none";
                startGame(); // ← この関数で listenToGameState などが呼ばれる想定
            } else {
                // 通常ロビー表示
                document.getElementById("nameInputSection").style.display = "none";
                document.getElementById("lobbySection").style.display = "block";
            }
        }



        async function updateHostStatus() {
            const gameRef = db.collection("games").doc(gameId);
            const playersRef = gameRef.collection("players");

            // ゲーム内でまだホストがいない場合、最初のプレイヤーにホスト権限を付与
            const snapshot = await playersRef.get();
            if (snapshot.empty) return;

            const nextHost = snapshot.docs[0];
            await nextHost.ref.update({ isHost: true });
        }

        function listenToLobby() {
            const playerListEl = document.getElementById("playerList");
            document.getElementById("gameIdDisplay").textContent = `ゲームID: ${gameId}`;
            db.collection("games").doc(gameId).collection("players").onSnapshot(snapshot => {
                playerListEl.innerHTML = "";
                numPlayers = snapshot.size;
                snapshot.forEach(doc => {
                    const li = document.createElement("li");
                    li.textContent = doc.data().name;
                    playerListEl.appendChild(li);
                });
                // ボタンの有効無効を正しく切り替える
                checkIfHost();
            });

            db.collection("games").doc(gameId).onSnapshot(doc => {
                if (doc.data().started) {
                    startGame();
                }
            });
        }
        async function requestCardSelection() {
            event.preventDefault();
            await db.collection("games").doc(gameId).update({
                selectedCards: [],
                selectingCards: true,
            }, { merge: true });
        }

        // ロビー画面にカード選択セクションを表示
        function showCardSelection() {
            // 表示用のカードリスト
            const cards = [
                "1", "2", "3",
                "heart", "crowbar", "diamond", "spade",
                "bomb", "special",
                "skip", "devil",
                "angel", "thief",
                "king", "revo", "elf"
            ];

            const cardSelectionContainer = document.getElementById("cardSelectionContainer");
            cardSelectionContainer.innerHTML = "";

            // 各カードに対応する画像と入力フィールドを作成
            cards.forEach(card => {
                // カードを表示するためのラッパーを作成
                const cardWrapper = document.createElement("div");
                cardWrapper.classList.add("card-wrapper");

                // 画像を作成（画像ファイルは適宜置き換えてください）
                const img = document.createElement("img");
                img.src = `${card}.png`;  // 例: images/1.png, images/heart.png
                img.alt = card;

                // ペア数を選択する入力フィールドを作成
                const label = document.createElement("label");
                label.textContent = `${card} ペア数: `;

                const input = document.createElement("input");
                input.type = "number";  // 数値の入力
                input.name = card;      // 名前をカード名に設定
                input.value = "0";      // デフォルトのペア数は 0
                input.min = "0";        // 0 以下の数値は選べないように
                input.max = "10";       // 任意の最大数値（例えば10ペアまで）
                input.step = "1";       // 1単位で変更できるように設定

                // カード画像とペア数選択をラップする
                cardWrapper.appendChild(img);
                cardWrapper.appendChild(label);
                cardWrapper.appendChild(input);

                // コンテナにカードを追加
                cardSelectionContainer.appendChild(cardWrapper);
            });
            document.getElementById("cardSelectionSection").style.display = "block";
            document.getElementById("lobbySection").style.display = "none";
        }
        function listenToCardSelectionStatus() {
            db.collection("games").doc(gameId).onSnapshot(doc => {
                const data = doc.data();
                if (data?.selectingCards) {
                    // selectingCardsがtrueならカード選択画面へ
                    showCardSelection();
                } else {
                    // selectingCardsがfalseならロビー画面へ
                    document.getElementById("cardSelectionSection").style.display = "none";
                    document.getElementById("lobbySection").style.display = "block";
                }
            });
        }
        async function backlobby() {
            event.preventDefault();
            handleCardSelection(event)
            saveSelectedCardsToFirebase(selectedCards);
            await db.collection("games").doc(gameId).update({
                selectingCards: false
            });
            selectedCards = [];
            const container = document.getElementById("cardSelectionContainer");
            container.innerHTML = "";
            const form = document.getElementById("cardSelectionForm");
            form.reset();
            document.getElementById("cardSelectionSection").style.display = "none";
            document.getElementById("lobbySection").style.display = "block";
        }

        // カード選択フォームが送信された際に呼ばれる
        async function handleCardSelection(event) {
            event.preventDefault();
            const cardInputs = document.querySelectorAll("input[type='number']");

            cardInputs.forEach(input => {
                const cardName = input.name;
                const pairCount = parseInt(input.value);
                if (pairCount > 0) {
                    for (let i = 0; i < pairCount; i++) {
                        selectedCards.push(cardName);
                        selectedCards.push(cardName);  // ペア数分だけカードを追加
                    }
                }
            });
        }

        // Firebaseに選ばれたカードを保存する関数
        async function saveSelectedCardsToFirebase(selectedCards) {
            await db.collection("games").doc(gameId).set({
                selectedCards: selectedCards
            }, { merge: true });
        }





        async function startGameInLobby() {
            // selectedCardsをFirebaseから取得
            const gameDoc = await db.collection("games").doc(gameId).get();
            const data = gameDoc.data();
            if (data && data.selectedCards) {
                // ここでcardsにselectedCardsをコピー！
                cards = [...data.selectedCards];
                shuffle(cards);
                const playerSnapshot = await db.collection("games").doc(gameId).collection("players").get();
                const playersArray = playerSnapshot.docs.map(doc => ({
                    id: doc.id,
                    name: doc.data().name
                }));

                // プレイヤーの順番をランダムにする
                shuffle(playersArray);
                let scoresObj = {};
                let Name = {};
                playersArray.forEach((player, index) => {
                    const playerIndex = index + 1;
                    scoresObj[playerIndex] = 0;
                    Name[playerIndex] = player.name;
                });

                await db.collection("games").doc(gameId).set({
                    cards: cards,
                    currentPlayer: 1,
                    PName: Name,
                    scores: scoresObj,
                    flipped: [],
                    matchedIndices: [],
                    skippedPlayers: [],
                    started: true
                }, { merge: true });


            }
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        function shuffleRemainingCardsOnly(cards, matchedIndices, flipped, includeFlipped = false) {
            const totalIndices = [...Array(cards.length).keys()];

            // includeFlipped に応じてシャッフル対象を決定
            const fixedIndices = includeFlipped
                ? new Set([...matchedIndices])
                : new Set([...matchedIndices, ...flipped]);

            const toShuffleIndices = totalIndices.filter(i => !fixedIndices.has(i));

            const toShuffleCards = toShuffleIndices.map(i => cards[i]);

            // Fisher-Yates シャッフル
            for (let i = toShuffleCards.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [toShuffleCards[i], toShuffleCards[j]] = [toShuffleCards[j], toShuffleCards[i]];
            }

            toShuffleIndices.forEach((idx, i) => {
                cards[idx] = toShuffleCards[i];
            });
        }


        function startGame() {
            document.getElementById("lobbySection").style.display = "none";
            document.getElementById("gameIdDisplay").style.display = "none";
            document.getElementById("gameBoard").style.display = "grid";
            document.querySelector(".score-board").style.display = "block";
            document.querySelector(".current-Player").style.display = "block";
            EFFECT();
            SpecialEffects();
            checkGameOver();
            listenToGameState();
        }

        let gameStateUnsubscribe = null;
        function listenToGameState() {
            if (gameStateUnsubscribe) return;

            gameStateUnsubscribe = db.collection("games").doc(gameId).onSnapshot(doc => {
                const data = doc.data();
                if (!data) return;
                cards = data.cards;
                PName = data.PName; // ← typoに注意！（Pname → PName）
                scores = data.scores;
                currentPlayer = data.currentPlayer;
                flippedCards = data.flipped;
                const matched = data.matchedIndices || [];
                const highlighted = data.highlightedIndices || [];

                renderBoard(cards, flippedCards, matched, highlighted, currentPlayer, PName);

                if (data.cardImages) {
                    cardImages = data.cardImages;
                    updateCardImagesOnScreen();
                }

                updateSP();
            });
        }


        function renderBoard(cards, flipped, matched, highlighted, currentPlayerNum, PName) {
            const gameBoard = document.getElementById("gameBoard");
            const scoreBoard = document.getElementById("scores");
            gameBoard.innerHTML = "";
            scoreBoard.innerHTML = "";

            cards.forEach((value, index) => {
                const card = document.createElement("div");
                card.className = "card";
                card.dataset.index = index;
                card.dataset.value = value;

                if (highlighted.includes(index)) {
                    card.classList.add("highlight-red");
                }

                if (flipped.includes(index) || matched.includes(index)) {
                    card.classList.add("flipped");
                    const img = document.createElement("img");
                    const src = cardImages[value];
                    if (src) {
                        img.src = `./${src}`;
                        img.alt = value;
                        img.style.width = "100%";
                        img.style.height = "100%";
                        card.appendChild(img);
                    }
                }

                if (
                    playerName === PName[currentPlayerNum] &&
                    !matched.includes(index) &&
                    !flipped.includes(index)
                ) {
                    card.addEventListener("click", () => handleCardClick(card));
                }

                gameBoard.appendChild(card);
            });
        }

        function updateCardImagesOnScreen() {
            document.querySelectorAll(".card.flipped img").forEach(img => {
                const cardDiv = img.parentElement;
                const value = cardDiv.dataset.value;
                const newSrc = cardImages[value];
                if (newSrc) {
                    img.src = `./${newSrc}`;
                }
            });
        }



        let isProcessing = false;

        async function handleCardClick(card) {
            if (isProcessing) return; // ロック中なら何もしない
            isProcessing = true;
            const index = parseInt(card.dataset.index);
            const doc = await db.collection("games").doc(gameId).get();  // ゲームドキュメントを取得
            const data = doc.data();
            const matched = data.matchedIndices || [];

            // 泥棒効果中なら特別な処理
            if (isThiefMode || isKaraageMode) {
                const index = parseInt(card.dataset.index);
                // 表 or matchedカードは無視
                if (data.flipped.includes(index) || matched.includes(index)) return;

                // プレイヤーが選んだカードを保存
                if (isThiefMode) selectedThiefIndex = index;
                if (isKaraageMode) selectedspecialIndex = index;

                const newFlipped = [...data.flipped, index];
                await db.collection("games").doc(gameId).update({ flipped: newFlipped });
                if (resolveThiefSelect) resolveThiefSelect(); // 👈 Promise 解決
                return;
            }

            data.flipped.push(index);
            await bombeffect(index, data, gameId, cards);
            await db.collection("games").doc(gameId).update({
                flipped: data.flipped,
                highlightedIndices: data.flipped
            }, { merge: true });
            if (data.flipped.length === 2) {
                const card1 = cards[data.flipped[0]];
                const card2 = cards[data.flipped[1]];
                if (card1 === card2) {
                    await triggerCardEffect(card1, data);
                    const docment = await db.collection("games").doc(gameId).get();  // ゲームドキュメントを取得
                    const updata = docment.data(); // 通常の一致したカード名を渡す
                    const newMatched = [...(updata.matchedIndices || []), ...updata.flipped];
                    await db.collection("games").doc(gameId).update({
                        currentPlayer: currentPlayer,
                        scores: scores,
                        flipped: [],
                        highlightedIndices: [],
                        noMatchPlayers: [],
                        matchedIndices: newMatched,
                    });
                    await checkGameOver();
                    isProcessing = false;
                } else {
                    setTimeout(async () => {
                        const gameRef = db.collection("games").doc(gameId);
                        const latestDoc = await gameRef.get();
                        const latestData = latestDoc.data();
                        const matched = latestData.matchedIndices || [];
                        const currentCards = [...latestData.cards]; // ← Firestoreのcardsを取得
                        const remaining = currentCards.length - matched.length;

                        let nextPlayer;
                        const extraTurnAfterMiss = latestData.extraTurnAfterMiss;
                        if (extraTurnAfterMiss === currentPlayer) {
                            nextPlayer = currentPlayer;
                            skipEffect();
                            await gameRef.update({ extraTurnAfterMiss: null }); // フラグをリセット
                        } else {
                            nextPlayer = await getNextPlayer(currentPlayer, numPlayers, latestData, gameId);
                        }

                        if (remaining <= 6) {
                            const updatedNoMatch = Array.from(new Set([...(latestData.noMatchPlayers || []), currentPlayer]));

                            if (updatedNoMatch.length >= numPlayers) {
                                shuffleRemainingCardsOnly(currentCards, matched, latestData.flipped, true);
                                elfEffect();
                                await gameRef.update({
                                    cards: currentCards, // ← シャッフル済み配列を保存
                                    noMatchPlayers: []
                                });
                            } else {
                                await gameRef.update({
                                    noMatchPlayers: updatedNoMatch
                                });
                            }
                        }


                        await gameRef.update({
                            currentPlayer: nextPlayer,
                            flipped: [],
                            highlightedIndices: []
                        });

                        isProcessing = false;
                    }, 1000);
                }
            } else {
                isProcessing = false;
            }
        }
        async function bombeffect(index, data, gameId, cards) {
            scores[currentPlayer] = 0;
            if (cards[index] === "bomb") {
                const matched = data.matchedIndices || [];

                // 他の未発見のbombを探して追加
                const additionalFlips = cards
                    .map((val, idx) => ({ val, idx }))
                    .filter(obj => obj.val === "bomb" && !data.flipped.includes(obj.idx) && !matched.includes(obj.idx))
                    .map(obj => obj.idx);

                data.flipped.push(...additionalFlips);

                // 3枚めくられた場合、最初のカード（非bomb）を裏返す
                if (data.flipped.length === 3) {
                    data.flipped.splice(0, 1); // 最初の1枚を削除

                }
                await db.collection("games").doc(gameId).update({
                    flipped: data.flipped,
                    scores: scores,
                });
            }
        }
        async function getNextPlayer(currentPlayer, numPlayers, data, gameId) {
            let next = currentPlayer;
            do {
                next = next % numPlayers + 1;
                const gameDoc = await db.collection("games").doc(gameId).get();
                const updatedData = gameDoc.data();
                const skippedPlayers = updatedData.skippedPlayers || [];

                if (skippedPlayers.includes(next)) {
                    if (Math.random() < 0.6) {
                        // FirebaseのDBからも削除
                        await db.collection("games").doc(gameId).update({
                            skippedPlayers: firebase.firestore.FieldValue.arrayRemove(next)
                        });
                    }
                    else {
                        devilEffect();
                    }

                    // 次のプレイヤーを探すため continue
                    continue;
                }

                break; // スキップ対象でない場合はループ終了

            } while (true);
            return next;  // 次のプレイヤーを返す

        }

        async function thiefEffect() {
            const doc = await db.collection("games").doc(gameId).get();
            const data = doc.data();
            const matched = data.matchedIndices || [];

            const flipped = [...data.flipped];
            const val1 = cards[selectedThiefIndex];

            // 選んだカードがまだflippedに入ってなければ追加
            if (!flipped.includes(selectedThiefIndex)) {
                flipped.push(selectedThiefIndex);
            }

            // 一致する support を探す
            const supportIndices = cards
                .map((val, idx) => ({ val, idx }))
                .filter(obj =>
                    obj.val === val1 &&
                    !flipped.includes(obj.idx) &&
                    !matched.includes(obj.idx)
                )
                .slice(0, 1);

            flipped.push(...supportIndices.map(obj => obj.idx));
            isProcessing = false;
            try {
                await db.collection("games").doc(gameId).update({
                    flipped: flipped,
                });
            } catch (error) {
                console.error("Firestore 更新エラー:", error);
            }
        }
        async function specialEffect() {
            const doc = await db.collection("games").doc(gameId).get();
            let data = doc.data();
            const matched = [...(data.matchedIndices || []), ...data.flipped,];
            const flipped = [...data.flipped];
            const val1 = cards[selectedspecialIndex];
            const totalCards = data.cards.length;
            const specialHiddenCards = cards
                .map((val, idx) => ({ val, idx })) // val: カードの種類, idx: 位置
                .filter(obj =>
                    specialTypes.includes(obj.val) &&
                    !data.flipped.includes(obj.idx) && // 表になっていない
                    !(data.matchedIndices || []).includes(obj.idx) // すでにペアになっていない
                );
            specialTypes.forEach(type => {
                const hasUnflippedUnmatchedCard = cards.some((val, idx) =>
                    val === type &&
                    !data.flipped.includes(idx) &&
                    !(data.matchedIndices || []).includes(idx)
                );
                if (hasUnflippedUnmatchedCard) {
                    cardImages[type] = "karaage.png";
                }
            });
            await db.collection("games").doc(gameId).update({
                cardImages: cardImages
            }, { merge: true });
            if (!flipped.includes(selectedspecialIndex)) {
                flipped.push(selectedspecialIndex);
            }
            const isSpecialCardSelected = specialHiddenCards.some(obj => obj.val === val1);
            if (isSpecialCardSelected) {
                const supportIndices = cards
                    .map((val, idx) => ({ val, idx }))
                    .filter(obj =>
                        obj.val === val1 &&
                        !flipped.includes(obj.idx) &&
                        !matched.includes(obj.idx)
                    )
                    .slice(0, 1);
                flipped.push(...supportIndices.map(obj => obj.idx));
                const pairIndex = supportIndices[0].idx;
                const newmatched = [...(data.matchedIndices || []), ...data.flipped, pairIndex];
                scores[currentPlayer]++;
                await db.collection("games").doc(gameId).update({
                    matchedIndices: newmatched,
                    flipped: [],
                    scores: scores,
                });

                if (newmatched.length === totalCards) {
                    isProcessing = false;
                    isKaraageMode = false;
                    const updates = {};
                    specialTypes.forEach(type => {
                        if (cardImages[type] === "karaage.png") {
                            updates[`cardImages.${type}`] = `${type}.png`;  // ネストフィールド指定
                        }
                    });

                    await db.collection("games").doc(gameId).update(updates);
                    finishkaraage2Effect();
                    await checkGameOver()
                    return; // ★★★ 関数を終了 ★★★
                }

                isProcessing = false;
                isKaraageMode = true;
                await new Promise(resolve => {
                    resolveThiefSelect = resolve;
                });
                karaageeEffect();
                await specialEffect();

            } else {
                flipped.pop();
                const updates = {};
                specialTypes.forEach(type => {
                    if (cardImages[type] === "karaage.png") {
                        updates[`cardImages.${type}`] = `${type}.png`;  // ネストフィールド指定
                    }
                });
                await db.collection("games").doc(gameId).update(updates);
                // 1秒待つ（1000ミリ秒）
                finishkaraage2Effect();
                await new Promise(resolve => setTimeout(resolve, 1000));
                const nextPlayer = await getNextPlayer(currentPlayer, numPlayers, data, gameId);
                await db.collection("games").doc(gameId).update({
                    flipped: flipped,
                }, { merge: true });

                isProcessing = false;
                isKaraageMode = false;

            }
        }




        async function triggerCardEffect(card1, data, index) {
            const totalCards = data.cards.length;
            const matched = data.matchedIndices || [];
            const unflippedCards = data.cards.filter((card, index) =>
                !matched.includes(index) && !data.flipped.includes(index)
            );
            await db.collection("games").doc(gameId).update({
                latestEffect: {
                    cardType: card1,
                    timestamp: Date.now()
                }
            });
            switch (card1) {
                case "heart":
                    scores[currentPlayer]++;
                    break;
                case "crowbar":
                    scores[currentPlayer]++;
                    break;
                case "diamond":
                    scores[currentPlayer]++;
                    break;
                case "spade":
                    scores[currentPlayer]++;
                    break;

                case "1":
                    scores[currentPlayer]++;
                    break;
                case "2":
                    scores[currentPlayer] += 2;
                    break;
                case "3":
                    scores[currentPlayer] += 3;
                    break;
                case "angel":
                    scores[currentPlayer] += 4;
                    break;
                case "devil": {
                    const random = Math.random(); // 0〜1のランダムな数（0.5未満なら前者、0.5以上なら後者）

                    if (random < 0.5) {
                        // スコアを -3 する（最小0に制限しておくのが一般的）
                        scores[currentPlayer] = Math.max(0, scores[currentPlayer] - 3);
                        await db.collection("games").doc(gameId).update({
                            scores: scores
                        });
                    } else {
                        // 一回休み → skippedPlayers に追加
                        await db.collection("games").doc(gameId).update({
                            skippedPlayers: firebase.firestore.FieldValue.arrayUnion(currentPlayer)
                        });
                    }
                    break;
                }


                case "revo":
                    // revoカードの場合の処理
                    // すべてのプレイヤーのスコアを均等にする
                    const totalPlayers = Object.keys(scores).length; // プレイヤー数を取得
                    const totalScore = Object.values(scores).reduce((a, b) => a + b, 0); // 現在のスコアの合計を計算
                    const equalScore = Math.floor(totalScore / totalPlayers); // 余りを切り捨てて均等なスコアを計算

                    // 各プレイヤーのスコアを均等に設定
                    for (let player in scores) {
                        scores[player] = equalScore;
                    }

                    break;
                case "skip":
                    scores[currentPlayer]++;
                    await db.collection("games").doc(gameId).update({
                        extraTurnAfterMiss: currentPlayer
                    });
                    break;

                case "thief":
                    // 泥棒モード開始
                    // 残りカードが2枚なら、isThiefMode と isKaraageMode を false にして処理をしない
                    if (unflippedCards.length === 0) {
                        scores[currentPlayer] += 2;
                        break;
                    }
                    else {
                        isProcessing = false;
                        isThiefMode = true;

                        // カードが選ばれるのを待つ
                        await new Promise(resolve => {
                            resolveThiefSelect = resolve;
                        });
                        // ↓カード選択後の処理
                        isThiefMode = false;
                        await thiefEffect(index);
                        scores[currentPlayer] += 2;
                        break;
                    }

                case "king":
                    // 現在のプレイヤーのスコアを取得
                    let currentPlayerScore = scores[currentPlayer];

                    // 他のプレイヤーのスコアを加算し、現在のプレイヤー以外のスコアをゼロにする
                    for (let playerNum = 1; playerNum <= numPlayers; playerNum++) {
                        if (playerNum !== currentPlayer) {
                            currentPlayerScore += scores[playerNum]; // 他のプレイヤーのスコアを加算
                            scores[playerNum] = 0; // 他のプレイヤーのスコアをゼロにする
                        }
                    }

                    // 現在のプレイヤーのスコアを更新
                    scores[currentPlayer] = currentPlayerScore;
                    break;

                case "special":
                    // 残りカードが2枚なら、isThiefMode と isKaraageMode を false にして処理をしない
                    if (unflippedCards.length === 0) {
                        scores[currentPlayer] += 2;
                        break;
                    } else {
                        isProcessing = false;
                        isKaraageMode = true;
                        scores[currentPlayer] += 2;
                        await db.collection("games").doc(gameId).update({ scores });
                        // カードが選ばれるのを待つ
                        await new Promise(resolve => {
                            resolveThiefSelect = resolve;
                        });
                        isKaraageMode = false;
                        // ↓カード選択後の処理
                        await specialEffect(index);
                        break;
                    }
                    isProcessing = false;
                    isKaraageMode = true;
                    scores[currentPlayer] += 2;
                    await db.collection("games").doc(gameId).update({ scores });
                    // カードが選ばれるのを待つ
                    await new Promise(resolve => {
                        resolveThiefSelect = resolve;
                    });
                    isKaraageMode = false;
                    // ↓カード選択後の処理
                    await specialEffect(index);

                    break;
                case "elf":
                    scores[currentPlayer] += 2;
                    shuffleRemainingCardsOnly(data.cards, data.matchedIndices, data.flipped, false);
                    await db.collection("games").doc(gameId).update({
                        cards: data.cards,
                    });
                    break;

            }
        }
        function EFFECT() {
            db.collection("games").doc(gameId).onSnapshot((doc) => {
                const data = doc.data();
                const effect = data.latestEffect;
                if (!effect) return;
                const effectKey = effect.cardType + "_" + effect.timestamp;
                if (effect && effectKey !== lastSeenEffectKey) {
                    lastSeenEffectKey = effectKey;
                    showCardEffect(effect.cardType);
                }
            });

        }
        function SpecialEffects() {
            db.collection("games").doc(gameId)
                .onSnapshot((doc) => {
                    const data = doc.data();
                    const effect = data.Effect;

                    if (effect && effect.timestamp !== lastEffectTimestamp) {
                        lastEffectTimestamp = effect.timestamp;

                        // エフェクトを画面に表示
                        showEffectModal(effect.image, effect.text);
                    }
                });

        }

        async function elfEffect() {
            await db.collection("games").doc(gameId).update({
                Effect: {
                    type: "elf",
                    text: "かわいそ～君たち…残念すぎてｗｗ",
                    image: "elf.png",
                    timestamp: Date.now()
                }
            });
        }
        async function devilEffect() {
            await db.collection("games").doc(gameId).update({
                Effect: {
                    type: "devil",
                    text: "まだすやすや寝とけ",
                    image: "devil.png",
                    timestamp: Date.now()
                }
            });
        }
        async function skipEffect() {
            await db.collection("games").doc(gameId).update({
                Effect: {
                    type: "skip",
                    text: "もう一回！ばちこりじゃ！",
                    image: "skip.png",
                    timestamp: Date.now()
                }
            });
        }

        async function karaageeEffect() {
            await db.collection("games").doc(gameId).update({
                Effect: {
                    type: "karaage",
                    text: "まだまだお腹すいちゃってるぅぅ",
                    image: "karaage.png",
                    timestamp: Date.now()
                }
            });
        }


        async function finishkaraage2Effect() {
            await db.collection("games").doc(gameId).update({
                Effect: {
                    type: "finishKaraage",
                    text: "大大大満足！！",
                    image: "karaage.png",
                    timestamp: Date.now()
                }
            });
        }

        function showEffectModal(imageSrc, text) {
            const effectImage = document.getElementById("effectImage");
            const effectText = document.getElementById("effectText");
            const modal = document.getElementById("effectModal");

            effectImage.src = imageSrc;
            effectText.innerText = text;

            modal.classList.remove("hidden");
            setTimeout(() => {
                modal.classList.add("hidden");
            }, 2000);
        }

        function showCardEffect(cardType) {
            const effectImage = document.getElementById("effectImage");
            const effectText = document.getElementById("effectText");
            const modal = document.getElementById("effectModal");

            // 画像と説明を設定
            effectImage.src = `${cardType}.png`; // カード画像パス（適宜修正）
            effectText.innerText = getCardEffectText(cardType); // 効果説明（↓関数作る）

            modal.classList.remove("hidden");
            setTimeout(() => {
                modal.classList.add("hidden");
            }, 2000);
        }

        // 効果説明をカードの種類に応じて返す
        function getCardEffectText(cardType) {
            switch (cardType) {
                case "bomb":
                    return "こんなところに爆弾が…得点が。おつかれ";
                case "heart":
                    return "何の変哲もないカード。ただの１点。ゴミ";
                case "diamond":
                    return "何の変哲もないカード。ただの１点。カス";
                case "spade":
                    return "何の変哲もないカード。ただの１点。雑魚";
                case "special":
                    return "雑魚のカードが、からあげ味に！？食べつくせ";
                case "crowbar":
                    return "何の変哲もないカード。ただの１点。草";
                case "1":
                    return "コツコツ1点！";
                case "2":
                    return "2点も！？有難く頂戴";
                case "3":
                    return "これはレアだ。この運命に乾杯！";
                case "angel":
                    return "天使が僕の下に…？かわいい…";
                case "devil":
                    return "とぅ。悪魔参上だ！やっぱ悪さ最高だぜぇぇ";
                case "skip":
                    return "大丈夫。まだ戦えるよ。";
                case "revo":
                    return "革命の火をあげろぉぉぉ。弱者に救いを";
                case "king":
                    return "吾が王だ。皆の者すべてよこせ";
                case "thief":
                    return "どんなカードでも奪ってきまっせ。任せてくだせぇ";
                case "elf":
                    return "カード分からなくなっちゃったね";
            }
        }


        async function updateSP() {
            const gameDoc = await db.collection("games").doc(gameId).get();
            //現在プレイヤー変更
            const gameData = gameDoc.data();
            const currentPlayerNum = gameData.currentPlayer;
            const PName = gameData.PName;
            const myplayerName = PName[currentPlayerNum];
            const playerDiv = document.getElementById("currentPlayer");
            playerDiv.innerHTML = `<h3>現在プレイヤー: ${myplayerName}</h3>`;

            //スコア更新
            const scoreBoard = document.getElementById("scores");
            scoreBoard.innerHTML = "";
            for (let i = 1; i <= numPlayers; i++) {
                scoreBoard.innerHTML += `<h3>プレイヤー${PName[i]} スコア: ${scores[i]}</h3>`;
            }
        }
        async function checkGameOver() {
            const gameDoc = await db.collection("games").doc(gameId).get();
            const data = gameDoc.data();

            const totalCards = data.cards.length;
            const matched = data.matchedIndices || [];
            if (matched.length === totalCards) {
                await db.collection("games").doc(gameId).update({
                    gameOver: true
                });
                await showGameOver();
            }
            db.collection("games").doc(gameId)
                .onSnapshot((doc) => {
                    const data = doc.data();
                    if (data?.gameOver) {
                        showGameOver();
                    }
                });
        }

        async function showGameOver() {
            setTimeout(async () => {
                const finalScoreEl = document.getElementById("finalScore");

                const gameDoc = await db.collection("games").doc(gameId).get();
                const data = gameDoc.data();

                // PName と scores を取得
                const PName = data.PName;
                const scores = data.scores;
                // scores と PName を使って [{name, score}] の配列を作る
                const rankingArray = Object.entries(scores).map(([playerNum, score]) => {
                    const name = PName[playerNum] ?? `プレイヤー${playerNum}`;
                    return { name, score };
                });

                // スコア降順でソート
                rankingArray.sort((a, b) => b.score - a.score);

                // 表示用の文字列を生成
                const rankingList = rankingArray
                    .map((entry, index) => {
                        const style = index === 0 ? 'style="color: red;"' : '';
                        return `<li ${style}>${index + 1}位: ${entry.name}（${entry.score} ペア）</li>`;
                    })
                    .join(""); // <li>要素の文字列を結合

                // 最終的なリストを finalScore の要素に挿入
                finalScoreEl.innerHTML = `<ul>${rankingList}</ul>`;

                // 文字を大きくするスタイル
                finalScoreEl.style.fontSize = "24px"; // サイズ調整
                finalScoreEl.style.lineHeight = "1.5"; // 行間の調整
                finalScoreEl.style.listStyleType = "none"; // 黒点を除去
                finalScoreEl.style.paddingLeft = "20px"; // 左にパディングを追加してインデント
                finalScoreEl.style.color = "#333"; // 文字の色を変更

                // ul 要素を左揃え
                const ul = finalScoreEl.querySelector('ul');
                ul.style.textAlign = 'left'; // 左揃え
                document.getElementById("gameOverModal").style.display = "flex";
            }, 2000);  // 1000ミリ秒（1秒）後に実行
        }





        async function restartGame() {
            document.getElementById("gameOverModal").style.display = "none";
            document.getElementById("gameBoard").style.display = "none";
            document.querySelector(".score-board").style.display = "none";
            document.querySelector(".current-Player").style.display = "none";
            document.getElementById("gameIdDisplay").style.display = "block"
            document.getElementById("lobbySection").style.display = "block";

            await db.collection("games").doc(gameId).update({
                started: false,
                gameOver: false,
                highlightedIndices: [],
                flipped: [],
                matchedIndices: [],
                scores: [],
                currentPlayer: [],
                PName: [],
                cardImages: cardImages,
                Effect: firebase.firestore.FieldValue.delete(),
                latestEffect: firebase.firestore.FieldValue.delete()
            }, { merge: true });
        }
        async function leaveGame() {
            if (!gameId || !playerId) return;

            const playerRef = db.collection("games").doc(gameId).collection("players").doc(playerId);
            const playerSnap = await playerRef.get();
            const playerData = playerSnap.data();

            // プレイヤー削除
            await playerRef.delete();

            // ホストなら、他の誰かをホストにする
            if (playerData?.isHost) {
                const playersSnapshot = await db.collection("games").doc(gameId).collection("players").get();
                if (!playersSnapshot.empty) {
                    const nextHost = playersSnapshot.docs[0];
                    await nextHost.ref.update({ isHost: true });
                }
            }

            // 全員が抜けたか確認
            await checkIfGameEmptyAndDelete();
            await updateHostUI();

            // ロビー画面から退出
            window.location.reload(); // またはホーム画面に戻す処理など
            window.addEventListener("beforeunload", async () => {
                await leaveGame();
            });
        }
        async function updateHostUI() {
            // ホストが変更された後にUIを更新
            await checkIfHost(); // 新しいホスト情報を確認してUIに反映
        }




        async function exitGame() {
            // プレイヤー情報をすべて削除
            const playersRef = db.collection("games").doc(gameId).collection("players");
            const playersSnapshot = await playersRef.get();
            const deletePromises = playersSnapshot.docs.map(doc => doc.ref.delete());
            await Promise.all(deletePromises);

            // ゲームドキュメントを削除
            await db.collection("games").doc(gameId).delete();
            location.reload();
        }
        async function checkIfGameEmptyAndDelete() {
            const playersRef = db.collection("games").doc(gameId).collection("players");
            const playersSnapshot = await playersRef.get();

            if (playersSnapshot.empty) {
                // プレイヤーがいなければゲームを削除
                await db.collection("games").doc(gameId).delete();
                location.reload();  // ゲームが削除された後、ページをリロード
            }
        }
        document.getElementById("gameIdInput").addEventListener("keydown", function (event) {
            if (event.key === "Enter") {
                joinGame();
            }
        });

        document.getElementById("playerNameInput").addEventListener("keydown", function (event) {
            if (event.key === "Enter") {
                enterLobby();
            }
        });

    </script>
</body>

</html>
