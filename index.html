<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ç¥çµŒè¡°å¼±</title>
    <style>
        .game-board {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 8px;
            padding: 10px;
        }

        .card {
            aspect-ratio: 5 / 7;
            width: 100%;
            border: 2px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: black;
            cursor: pointer;
        }

        .flipped {
            background-color: white;
        }

        .score-board {
            margin-top: 20px;
            text-align: center;
            font-size: 20px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
        }

        .effect-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.3s ease;
        }

        .effect-modal img {
            width: 200px;
            height: auto;
            margin-bottom: 20px;
        }

        .effect-modal.hidden {
            display: none;
        }

        #effectText {
            font-size: 32px;
            /* æ–‡å­—ã‚’å¤§ãã */
            color: #00aaff;
            /* é’ç³»ã®ã‚«ãƒ©ãƒ¼ã« */
            text-align: center;
            /* ä¸­å¤®æƒãˆ */
            font-weight: bold;
            /* å¤ªå­—ã«ã—ã¦è¦‹ã‚„ã™ã */
            margin-top: 10px;
            /* ç”»åƒã¨ã®ä½™ç™½ */
        }

        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .start-menu {
            text-align: center;
            margin-top: 50px;
        }




        #gameBoard,
        .score-board,
        .current-Player {
            display: none;
        }
    </style>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
</head>

<body>

    <!-- ã‚²ãƒ¼ãƒ å‚åŠ ç”»é¢ -->
    <div id="joinGameSection">
        <h2>ã‚²ãƒ¼ãƒ ã«å‚åŠ </h2>
        <input type="text" id="gameIdInput" placeholder="ã‚²ãƒ¼ãƒ IDã‚’å…¥åŠ›">
        <button onclick="joinGame()">æ¬¡ã¸</button>
    </div>

    <!-- åå‰å…¥åŠ› -->
    <div id="nameInputSection" style="display:none;">
        <h2>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åã‚’å…¥åŠ›</h2>
        <input type="text" id="playerNameInput" placeholder="åå‰">
        <button onclick="enterLobby()">ãƒ­ãƒ“ãƒ¼ã«å‚åŠ </button>
    </div>

    <!-- ãƒ­ãƒ“ãƒ¼ -->
    <div id="lobbySection" style="display:none;">
        <h2>å¾…æ©Ÿä¸­ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</h2>
        <ul id="playerList"></ul>
        <button id="startGameBtn" onclick="startGameInLobby()" disabled>ã‚²ãƒ¼ãƒ é–‹å§‹</button>
    </div>
    <div id="gameIdDisplay" style="margin-top: 10px; font-size: 18px; font-weight: bold;"></div>


    <!-- ã‚²ãƒ¼ãƒ ç”»é¢ -->
    <div class="current-Player">
        <div id="currentPlayer"></div>
    </div>
    <div class="game-board" id="gameBoard"></div>
    <div class="score-board">
        <div id="scores"></div>
    </div>
    <div id="gameOverModal" class="modal">
        <div class="modal-content">
            <h2>ã‚²ãƒ¼ãƒ çµ‚äº†ï¼</h2>
            <p id="finalScore"></p>
            <button onclick="restartGame()">ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤</button>
            <button onclick="exitGame()">çµ‚äº†</button>
        </div>
    </div>
    <div id="effectModal" class="effect-modal hidden">
        <img id="effectImage" src="" alt="Card Image" />
        <div id="effectText"></div>
    </div>


    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyBvjSDUh-IaCZQ17bE3Q4IfI0yZDqbDcz0",
            authDomain: "flipcards-5ca31.firebaseapp.com",
            projectId: "flipcards-5ca31",
            storageBucket: "flipcards-5ca31.appspot.com",
            messagingSenderId: "599139871804",
            appId: "1:599139871804:web:5402c51a0acfd75cd36739",
            measurementId: "G-KB8ZCG0HG8"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        let gameId = "";
        let playerName = "";
        let myplayerName = "";
        let currentPlayer = 1;
        let PName = {};
        let numPlayers = 0;
        let playerId = "";
        let skipdata = 0;
        let cards = [
            "1", "1", "1", "1", "1", "1", "2", "2", "2", "2", "3", "3",
            "heart", "heart", "heart", "heart", "heart", "heart", "heart", "heart",
            "crowbar", "crowbar", "crowbar", "crowbar", "crowbar", "crowbar", "crowbar", "crowbar",
            "bomb", "bomb", "special", "special", "skip", "skip", "skip", "skip",
            "devil", "devil", "devil", "devil", "angel", "angel", "angel", "angel",
            "thief", "thief", "king", "king", "revo", "revo"
        ];

        const cardImages = {
            "bomb": "bomb.png",
            "special": "special.png",
            "skip": "skip.png",
            "devil": "devil.png",
            "angel": "angel.png",
            "thief": "thief.png",
            "king": "king.png",
            "revo": "revo.png",
            "heart": "heart.png",
            "crowbar": "crowbar.png",
            "karaage": "karaage.png",
            "1": "1.png",
            "2": "2.png",
            "3": "3.png",

        };
        let isThiefMode = false;        // æ³¥æ£’åŠ¹æœä¸­ã‹ã©ã†ã‹
        let resolveThiefSelect = null;
        let selectedThiefIndex = null;

        const specialTypes = ["heart", "crowbar"];
        const originalCardImages = {
            heart: "heart.png",
            crowbar: "crowbar.png",
        };
        let selectedspecialIndex = null;
        let originalSpecialCards = []; // å…ƒã®çŠ¶æ…‹ä¿å­˜ç”¨
        let isKaraageMode = false;

        let scores = {};
        let flippedCards = [];

        function joinGame() {
            gameId = document.getElementById("gameIdInput").value.trim();
            if (!gameId) return alert("ã‚²ãƒ¼ãƒ IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
            document.getElementById("joinGameSection").style.display = "none";
            document.getElementById("nameInputSection").style.display = "block";
        }

        async function enterLobby() {
            playerName = document.getElementById("playerNameInput").value.trim();
            if (!playerName) return alert("åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");

            playerId = `player_${Date.now()}`;
            await db.collection("games").doc(gameId).set({ started: false }, { merge: true });
            await db.collection("games").doc(gameId).collection("players").doc(playerId).set({
                name: playerName,
            });

            document.getElementById("nameInputSection").style.display = "none";
            document.getElementById("lobbySection").style.display = "block";

            listenToLobby();
        }

        function listenToLobby() {
            const playerListEl = document.getElementById("playerList");
            document.getElementById("gameIdDisplay").textContent = `ã‚²ãƒ¼ãƒ ID: ${gameId}`;
            db.collection("games").doc(gameId).collection("players").onSnapshot(snapshot => {
                playerListEl.innerHTML = "";
                numPlayers = snapshot.size;
                snapshot.forEach(doc => {
                    const li = document.createElement("li");
                    li.textContent = doc.data().name;
                    playerListEl.appendChild(li);
                });
                if (numPlayers >= 1) {
                    document.getElementById("startGameBtn").disabled = false;
                }
            });

            db.collection("games").doc(gameId).onSnapshot(doc => {
                if (doc.data().started) {
                    startGame();
                }
            });
        }

        async function startGameInLobby() {
            shuffle(cards);
            const playerSnapshot = await db.collection("games").doc(gameId).collection("players").get();
            let scoresObj = {};
            let Name = {};
            let index = 1;
            playerSnapshot.forEach(doc => {
                const name = doc.data().name;
                scoresObj[index] = 0;
                Name[index] = name;
                index++;
            });

            await db.collection("games").doc(gameId).set({
                cards,
                currentPlayer: 1,
                PName: Name,
                scores: scoresObj,
                flipped: [],
                matchedIndices: [],
                skippedPlayers: [],
                started: true
            }, { merge: true });
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function startGame() {
            document.getElementById("lobbySection").style.display = "none";
            document.getElementById("gameIdDisplay").style.display = "none";
            document.getElementById("gameBoard").style.display = "grid";
            document.querySelector(".score-board").style.display = "block";
            document.querySelector(".current-Player").style.display = "block";

            listenToGameState();
        }

        let gameStateUnsubscribe = null;
        function listenToGameState() {
            if (gameStateUnsubscribe) return;
            gameStateUnsubscribe = db.collection("games").doc(gameId).onSnapshot(doc => {
                const data = doc.data();
                if (!data) return;
                cards = data.cards;
                PName = data.Pname;
                scores = data.scores;
                currentPlayer = data.currentPlayer;
                flippedCards = data.flipped;


                renderBoard(flippedCards);
                updateSP();
            });
        }

        function renderBoard(flipped) {
            const gameBoard = document.getElementById("gameBoard");
            const scoreBoard = document.getElementById("scores"); // â† è¿½åŠ 
            gameBoard.innerHTML = "";
            scoreBoard.innerHTML = ""; // â† ã‚¹ã‚³ã‚¢ã‚‚æ¶ˆã™

            const img = document.createElement("img");


            db.collection("games").doc(gameId).get().then(doc => {
                const data = doc.data();
                const matched = data.matchedIndices || [];
                const scores = data.scores || {};
                const currentPlayerNum = data.currentPlayer;
                const PName = data.PName;
                const myplayerName = PName[currentPlayerNum];

                // --- ã‚«ãƒ¼ãƒ‰æç”»éƒ¨åˆ† ---




                cards.forEach((value, index) => {
                    const card = document.createElement("div");
                    card.className = "card";
                    card.dataset.index = index;
                    card.dataset.value = value;

                    if (flipped.includes(index) || matched.includes(index)) {
                        card.classList.add("flipped");
                        const img = document.createElement("img");
                        const src = cardImages[value];
                        if (src) {
                            img.src = `./${src}`;
                            img.alt = value; // ç”»åƒãŒèª­ã¿è¾¼ã‚ãªã„ã¨ãã®ä»£æ›¿ãƒ†ã‚­ã‚¹ãƒˆ
                            img.style.width = "100%"; // å¿…è¦ã«å¿œã˜ã¦ã‚µã‚¤ã‚ºèª¿æ•´
                            img.style.height = "100%";
                            card.appendChild(img);
                        }

                    } else {
                    }

                    if (playerName === myplayerName &&
                        !matched.includes(index) &&
                        !flipped.includes(index)) {
                        card.addEventListener("click", () => handleCardClick(card));
                    }

                    gameBoard.appendChild(card);
                });
            });
        }


        let isProcessing = false;

        async function handleCardClick(card) {
            if (isProcessing) return; // ãƒ­ãƒƒã‚¯ä¸­ãªã‚‰ä½•ã‚‚ã—ãªã„
            isProcessing = true;
            const index = parseInt(card.dataset.index);
            const doc = await db.collection("games").doc(gameId).get();  // ã‚²ãƒ¼ãƒ ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å–å¾—
            const data = doc.data();
            const matched = data.matchedIndices || [];

            // æ³¥æ£’åŠ¹æœä¸­ãªã‚‰ç‰¹åˆ¥ãªå‡¦ç†
            if (isThiefMode) {
                console.log(348)
                const index = parseInt(card.dataset.index);

                // è¡¨ or matchedã‚«ãƒ¼ãƒ‰ã¯ç„¡è¦–
                if (data.flipped.includes(index) || matched.includes(index)) return;

                selectedThiefIndex = index; // ğŸ‘ˆ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé¸ã‚“ã  index ã‚’ä¿å­˜
                const newFlipped = [...data.flipped, index];
                await db.collection("games").doc(gameId).update({ flipped: newFlipped });

                if (resolveThiefSelect) resolveThiefSelect(); // ğŸ‘ˆ Promise ã‚’è§£æ±º
                return;
            }
            if (isKaraageMode) {
                console.log(348)
                const index = parseInt(card.dataset.index);
                // è¡¨ or match
                // ã‚«ãƒ¼ãƒ‰ã¯ç„¡è¦–
                if (data.flipped.includes(index) || matched.includes(index)) return;

                selectedspecialIndex = index; // ğŸ‘ˆ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé¸ã‚“ã  index ã‚’ä¿å­˜
                const newFlipped = [...data.flipped, index];
                await db.collection("games").doc(gameId).update({ flipped: newFlipped });

                if (resolveThiefSelect) resolveThiefSelect(); // ğŸ‘ˆ Promise ã‚’è§£æ±º
                return;
            }

            data.flipped.push(index);
            await bombeffect(index, data, gameId, cards);

            await db.collection("games").doc(gameId).update({ flipped: data.flipped });

            if (data.flipped.length === 2) {
                const card1 = cards[data.flipped[0]];
                const card2 = cards[data.flipped[1]];
                console.log("flipped indexes:", data.flipped);
                console.log("card1:", card1, "card2:", card2);

                if (card1 === card2) {
                    showCardEffect(card1);
                    await triggerCardEffect(card1, data);
                    const docment = await db.collection("games").doc(gameId).get();  // ã‚²ãƒ¼ãƒ ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å–å¾—
                    const updata = docment.data(); // é€šå¸¸ã®ä¸€è‡´ã—ãŸã‚«ãƒ¼ãƒ‰åã‚’æ¸¡ã™
                    const newMatched = [...(updata.matchedIndices || []), ...updata.flipped];
                    const nextPlayer = await getNextPlayer(currentPlayer, numPlayers, data, gameId);
                    await db.collection("games").doc(gameId).update({
                        currentPlayer: nextPlayer,
                        scores: scores,
                        flipped: [],
                        matchedIndices: newMatched
                    });
                    await checkGameOver();
                    isProcessing = false;
                } else {
                    setTimeout(async () => {
                        const nextPlayer = await getNextPlayer(currentPlayer, numPlayers, data, gameId);
                        await db.collection("games").doc(gameId).update({
                            currentPlayer: nextPlayer,
                            flipped: []
                        });

                        isProcessing = false;
                    }, 1000);
                }
            } else {
                isProcessing = false;
            }
        }



        async function bombeffect(index, data, gameId, cards) {
            scores[currentPlayer] = 0;
            if (cards[index] === "bomb") {
                const matched = data.matchedIndices || [];

                // ä»–ã®æœªç™ºè¦‹ã®bombã‚’æ¢ã—ã¦è¿½åŠ 
                const additionalFlips = cards
                    .map((val, idx) => ({ val, idx }))
                    .filter(obj => obj.val === "bomb" && !data.flipped.includes(obj.idx) && !matched.includes(obj.idx))
                    .map(obj => obj.idx);

                data.flipped.push(...additionalFlips);

                // 3æšã‚ãã‚‰ã‚ŒãŸå ´åˆã€æœ€åˆã®ã‚«ãƒ¼ãƒ‰ï¼ˆébombï¼‰ã‚’è£è¿”ã™
                if (data.flipped.length === 3) {
                    data.flipped.splice(0, 1); // æœ€åˆã®1æšã‚’å‰Šé™¤

                    await db.collection("games").doc(gameId).update({
                        flipped: data.flipped,
                        scores: scores,
                    });

                    console.log("æ–°ã—ã„ flipped é…åˆ—:", data.flipped);
                } else {
                    // å¿…è¦ãªã‚‰ä»–ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’æ›¸ã
                }
            }
        }
        async function getNextPlayer(currentPlayer, numPlayers, data, gameId) {
            let next = currentPlayer;
            do {
                next = next % numPlayers + 1;
                console.log("ã‚¿ãƒ¼ãƒ³", next);
                const gameDoc = await db.collection("games").doc(gameId).get();
                const updatedData = gameDoc.data();
                const skippedPlayers = updatedData.skippedPlayers || [];

                if (skippedPlayers.includes(next)) {
                    if (Math.random() < 0.8) {
                        // Firebaseã®DBã‹ã‚‰ã‚‚å‰Šé™¤
                        await db.collection("games").doc(gameId).update({
                            skippedPlayers: firebase.firestore.FieldValue.arrayRemove(next)
                        });
                    }
                    else {

                    }

                    // æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ¢ã™ãŸã‚ continue
                    continue;
                }

                break; // ã‚¹ã‚­ãƒƒãƒ—å¯¾è±¡ã§ãªã„å ´åˆã¯ãƒ«ãƒ¼ãƒ—çµ‚äº†

            } while (true);
            return next;  // æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¿”ã™

        }

        async function thiefEffect() {
            const doc = await db.collection("games").doc(gameId).get();
            const data = doc.data();
            const matched = data.matchedIndices || [];

            const flipped = [...data.flipped];
            const val1 = cards[selectedThiefIndex];

            // é¸ã‚“ã ã‚«ãƒ¼ãƒ‰ãŒã¾ã flippedã«å…¥ã£ã¦ãªã‘ã‚Œã°è¿½åŠ 
            if (!flipped.includes(selectedThiefIndex)) {
                flipped.push(selectedThiefIndex);
            }

            // ä¸€è‡´ã™ã‚‹ support ã‚’æ¢ã™
            const supportIndices = cards
                .map((val, idx) => ({ val, idx }))
                .filter(obj =>
                    obj.val === val1 &&
                    !flipped.includes(obj.idx) &&
                    !matched.includes(obj.idx)
                )
                .slice(0, 1);

            flipped.push(...supportIndices.map(obj => obj.idx));
            isProcessing = false;
            try {
                await db.collection("games").doc(gameId).update({
                    flipped: flipped,
                });
                console.log("Flipped by thiefEffect:", flipped);
            } catch (error) {
                console.error("Firestore æ›´æ–°ã‚¨ãƒ©ãƒ¼:", error);
            }
        }
        async function specialEffect() {
            const doc = await db.collection("games").doc(gameId).get();
            const data = doc.data();
            const matched = [...(data.matchedIndices || []), ...data.flipped];
            const flipped = [...data.flipped];
            const val1 = cards[selectedspecialIndex];
            const specialHiddenCards = cards
                .map((val, idx) => ({ val, idx })) // val: ã‚«ãƒ¼ãƒ‰ã®ç¨®é¡, idx: ä½ç½®
                .filter(obj =>
                    specialTypes.includes(obj.val) &&
                    !data.flipped.includes(obj.idx) && // è¡¨ã«ãªã£ã¦ã„ãªã„
                    !(data.matchedIndices || []).includes(obj.idx) // ã™ã§ã«ãƒšã‚¢ã«ãªã£ã¦ã„ãªã„
                );
            specialTypes.forEach(type => {
                const hasUnflippedUnmatchedCard = cards.some((val, idx) =>
                    val === type &&
                    !data.flipped.includes(idx) &&
                    !(data.matchedIndices || []).includes(idx)
                );

                if (hasUnflippedUnmatchedCard) {
                    cardImages[type] = "karaage.png";
                }
            });

            if (!flipped.includes(selectedspecialIndex)) {
                flipped.push(selectedspecialIndex);
            }
            const isSpecialCardSelected = specialHiddenCards.some(obj => obj.val === val1);
            if (isSpecialCardSelected) {
                const supportIndices = cards
                    .map((val, idx) => ({ val, idx }))
                    .filter(obj =>
                        obj.val === val1 &&
                        !flipped.includes(obj.idx) &&
                        !matched.includes(obj.idx)
                    )
                    .slice(0, 1);
                flipped.push(...supportIndices.map(obj => obj.idx));
                scores[currentPlayer]++;
                await db.collection("games").doc(gameId).update({
                    flipped: flipped,
                    matchedIndices: matched,
                    scores: scores
                });
                isProcessing = false;
                isKaraageMode = true;
                await new Promise(resolve => {
                    resolveThiefSelect = resolve;
                });
                await specialEffect();
            } else {
                flipped.pop();
                specialTypes.forEach(type => {
                    // ã‚‚ã—ãã®ã‚«ãƒ¼ãƒ‰ãŒ karaage.png ã«ãªã£ã¦ã„ã‚‹å ´åˆã€å…ƒã®ã‚«ãƒ¼ãƒ‰ã«æˆ»ã™
                    if (cardImages[type] === "karaage.png") {
                        // å…ƒã®ç”»åƒã«æˆ»ã™ï¼ˆä¾‹ãˆã° "original.png" ã¨ä»®å®šï¼‰
                        cardImages[type] = `${type}.png`; // typeã«åŸºã¥ã„ãŸå…ƒã®ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«å
                    }
                });
                // 1ç§’å¾…ã¤ï¼ˆ1000ãƒŸãƒªç§’ï¼‰
                await new Promise(resolve => setTimeout(resolve, 1000));
                const nextPlayer = await getNextPlayer(currentPlayer, numPlayers, data, gameId);
                await db.collection("games").doc(gameId).update({
                    flipped: flipped,
                    cardImages: cardImages
                });
                isProcessing = false;
                isKaraageMode = false;
            }

        }

        async function triggerCardEffect(card1, data, index) {

            switch (card1) {
                case "heart":
                    scores[currentPlayer]++;
                    break;
                case "crowbar":
                    scores[currentPlayer]++;
                    break;
                case "1":
                    scores[currentPlayer]++;
                    break;
                case "2":
                    scores[currentPlayer] += 2;
                    break;
                case "3":
                    scores[currentPlayer] += 3;
                    break;
                case "angel":
                    console.log("å¾—ç‚¹", scores[currentPlayer])
                    scores[currentPlayer] += 4;
                    console.log("å¾—ç‚¹", scores[currentPlayer])
                    break;
                case "devil": {
                    const random = Math.random(); // 0ã€œ1ã®ãƒ©ãƒ³ãƒ€ãƒ ãªæ•°ï¼ˆ0.5æœªæº€ãªã‚‰å‰è€…ã€0.5ä»¥ä¸Šãªã‚‰å¾Œè€…ï¼‰

                    if (random < 0.5) {
                        // ã‚¹ã‚³ã‚¢ã‚’ -3 ã™ã‚‹ï¼ˆæœ€å°0ã«åˆ¶é™ã—ã¦ãŠãã®ãŒä¸€èˆ¬çš„ï¼‰
                        scores[currentPlayer] = Math.max(0, scores[currentPlayer] - 3);
                        await db.collection("games").doc(gameId).update({
                            scores: scores
                        });
                        console.log("æ‚ªé­”ã®åŠ¹æœï¼šã‚¹ã‚³ã‚¢ -3");
                    } else {
                        // ä¸€å›ä¼‘ã¿ â†’ skippedPlayers ã«è¿½åŠ 
                        await db.collection("games").doc(gameId).update({
                            skippedPlayers: firebase.firestore.FieldValue.arrayUnion(currentPlayer)
                        });
                        console.log("æ‚ªé­”ã®åŠ¹æœï¼šä¸€å›ä¼‘ã¿");
                    }
                    break;
                }


                case "revo":
                    // revoã‚«ãƒ¼ãƒ‰ã®å ´åˆã®å‡¦ç†
                    // ã™ã¹ã¦ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ã‚³ã‚¢ã‚’å‡ç­‰ã«ã™ã‚‹
                    const totalPlayers = Object.keys(scores).length; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ•°ã‚’å–å¾—
                    const totalScore = Object.values(scores).reduce((a, b) => a + b, 0); // ç¾åœ¨ã®ã‚¹ã‚³ã‚¢ã®åˆè¨ˆã‚’è¨ˆç®—
                    const equalScore = Math.floor(totalScore / totalPlayers); // ä½™ã‚Šã‚’åˆ‡ã‚Šæ¨ã¦ã¦å‡ç­‰ãªã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—

                    // å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ã‚³ã‚¢ã‚’å‡ç­‰ã«è¨­å®š
                    for (let player in scores) {
                        scores[player] = equalScore;
                    }

                    break;
                case "skip":
                    scores[currentPlayer]++;
                    currentPlayer = currentPlayer % numPlayers + 1;
                    await db.collection("games").doc(gameId).update({ currentPlayer });
                    break;

                case "thief":
                    // æ³¥æ£’ãƒ¢ãƒ¼ãƒ‰é–‹å§‹
                    console.log(568)
                    isProcessing = false;
                    isThiefMode = true;


                    // ã‚«ãƒ¼ãƒ‰ãŒé¸ã°ã‚Œã‚‹ã®ã‚’å¾…ã¤
                    await new Promise(resolve => {
                        resolveThiefSelect = resolve;
                    });

                    // â†“ã‚«ãƒ¼ãƒ‰é¸æŠå¾Œã®å‡¦ç†
                    isThiefMode = false;
                    await thiefEffect(index);
                    scores[currentPlayer] += 2;
                    break;
                case "king":
                    // ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ã‚³ã‚¢ã‚’å–å¾—
                    let currentPlayerScore = scores[currentPlayer];

                    // ä»–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ã‚³ã‚¢ã‚’åŠ ç®—ã—ã€ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä»¥å¤–ã®ã‚¹ã‚³ã‚¢ã‚’ã‚¼ãƒ­ã«ã™ã‚‹
                    for (let playerNum = 1; playerNum <= numPlayers; playerNum++) {
                        if (playerNum !== currentPlayer) {
                            currentPlayerScore += scores[playerNum]; // ä»–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ã‚³ã‚¢ã‚’åŠ ç®—
                            scores[playerNum] = 0; // ä»–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ã‚³ã‚¢ã‚’ã‚¼ãƒ­ã«ã™ã‚‹
                        }
                    }

                    // ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ã‚³ã‚¢ã‚’æ›´æ–°
                    scores[currentPlayer] = currentPlayerScore;
                    break;

                case "special":
                    isProcessing = false;
                    isKaraageMode = true;
                    scores[currentPlayer] += 2;
                    await db.collection("games").doc(gameId).update({ scores });
                    // ã‚«ãƒ¼ãƒ‰ãŒé¸ã°ã‚Œã‚‹ã®ã‚’å¾…ã¤
                    await new Promise(resolve => {
                        resolveThiefSelect = resolve;
                    });
                    isKaraageMode = false;
                    // â†“ã‚«ãƒ¼ãƒ‰é¸æŠå¾Œã®å‡¦ç†
                    await specialEffect(index);

                    break;
            }
        }
        function showCardEffect(cardType) {
            const effectImage = document.getElementById("effectImage");
            const effectText = document.getElementById("effectText");
            const modal = document.getElementById("effectModal");

            // ç”»åƒã¨èª¬æ˜ã‚’è¨­å®š
            effectImage.src = `${cardType}.png`; // ã‚«ãƒ¼ãƒ‰ç”»åƒãƒ‘ã‚¹ï¼ˆé©å®œä¿®æ­£ï¼‰
            effectText.innerText = getCardEffectText(cardType); // åŠ¹æœèª¬æ˜ï¼ˆâ†“é–¢æ•°ä½œã‚‹ï¼‰

            modal.classList.remove("hidden");
            modal.addEventListener("click", () => {
                modal.classList.add("hidden");
            });

        }

        // åŠ¹æœèª¬æ˜ã‚’ã‚«ãƒ¼ãƒ‰ã®ç¨®é¡ã«å¿œã˜ã¦è¿”ã™
        function getCardEffectText(cardType) {
            switch (cardType) {
                case "bomb":
                    return "ã“ã‚“ãªã¨ã“ã‚ã«çˆ†å¼¾ãŒâ€¦å¾—ç‚¹ãŒã€‚ãŠã¤ã‹ã‚Œ";
                case "heart":
                    return "ä½•ã®å¤‰å“²ã‚‚ãªã„ã‚«ãƒ¼ãƒ‰ã€‚ãŸã ã®ä¸€ç‚¹ã€‚ç„¡å‘³ç„¡è‡­";
                case "special":
                    return "ç„¡å‘³ã®ã‚«ãƒ¼ãƒ‰ãŒã€ã‹ã‚‰ã‚ã’å‘³ã«ï¼ï¼Ÿé£Ÿã¹ã¤ãã›";
                case "crowbar":
                    return "ä½•ã®å¤‰å“²ã‚‚ãªã„ã‚«ãƒ¼ãƒ‰ã€‚ãŸã ã®ä¸€ç‚¹ã€‚ç„¡å‘³ç„¡è‡­";
                case "1":
                    return "ã‚³ãƒ„ã‚³ãƒ„1ç‚¹ï¼";
                case "2":
                    return "2ç‚¹ã‚‚ï¼ï¼Ÿæœ‰é›£ãé ‚æˆ´";
                case "3":
                    return "ã“ã‚Œã¯ãƒ¬ã‚¢ã ã€‚ã“ã®é‹å‘½ã«ä¹¾æ¯ï¼";
                case "angel":
                    return "å¤©ä½¿ãŒåƒ•ã®ä¸‹ã«â€¦ï¼Ÿã‚ã‚ŠãŒãŸã‚„";
                case "devil":
                    return "ã¨ã…ã€‚æ‚ªé­”å‚ä¸Šã ï¼ã‚„ã£ã±æ‚ªã•æœ€é«˜ã ãœã‡ã‡";
                case "skip":
                    return "æ¬¡ã®äººä½•ã‚‚ã§ããªã„ã­ã€‚ã©ã‚“ã¾ã„ã€‚";
                case "revo":
                    return "é©å‘½ã®ç«ã‚’ã‚ã’ã‚ã‰ã‰ã‰ã€‚å¼±è€…ã«æ•‘ã„ã‚’";
                case "king":
                    return "å¾ãŒç‹ã ã€‚çš†ã®è€…ã™ã¹ã¦ã‚ˆã“ã›";
                case "thief":
                    return "ã©ã‚“ãªã‚«ãƒ¼ãƒ‰ã§ã‚‚å¥ªã£ã¦ãã¾ã£ã›ã€‚ä»»ã›ã¦ãã ã›ã‡";
                case "karaage":
                    return "ã†ã‚ã‡ã‚ˆã‰ã€‚ã¾ã ã¾ã é£Ÿã‚ã—ã¦ãã‚Œã‡";
            }
        }


        async function updateSP() {
            const gameDoc = await db.collection("games").doc(gameId).get();
            //ç¾åœ¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å¤‰æ›´
            const gameData = gameDoc.data();
            const currentPlayerNum = gameData.currentPlayer;
            const PName = gameData.PName;
            const myplayerName = PName[currentPlayerNum];
            const playerDiv = document.getElementById("currentPlayer");
            playerDiv.innerHTML = `<h3>ç¾åœ¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: ${myplayerName}</h3>`;

            //ã‚¹ã‚³ã‚¢æ›´æ–°
            const scoreBoard = document.getElementById("scores");
            scoreBoard.innerHTML = "";
            for (let i = 1; i <= numPlayers; i++) {
                scoreBoard.innerHTML += `<h3>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${PName[i]} ã‚¹ã‚³ã‚¢: ${scores[i]}</h3>`;
            }
        }
        async function checkGameOver() {
            const gameDoc = await db.collection("games").doc(gameId).get();
            const data = gameDoc.data();

            const totalCards = cards.length;
            const matched = data.matchedIndices || [];

            if (matched.length === totalCards) {
                await showGameOver();
            }
        }


        async function showGameOver() {
            const finalScoreEl = document.getElementById("finalScore");

            const gameDoc = await db.collection("games").doc(gameId).get();
            const data = gameDoc.data();

            // PName ã¨ scores ã‚’å–å¾—
            const PName = data.PName;
            const scores = data.scores;
            // scores ã¨ PName ã‚’ä½¿ã£ã¦ [{name, score}] ã®é…åˆ—ã‚’ä½œã‚‹
            const rankingArray = Object.entries(scores).map(([playerNum, score]) => {
                const name = PName[playerNum] ?? `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${playerNum}`;
                return { name, score };
            });

            // ã‚¹ã‚³ã‚¢é™é †ã§ã‚½ãƒ¼ãƒˆ
            rankingArray.sort((a, b) => b.score - a.score);

            // è¡¨ç¤ºç”¨ã®æ–‡å­—åˆ—ã‚’ç”Ÿæˆ
            const rankingList = rankingArray
                .map((entry, index) => {
                    const style = index === 0 ? 'style="color: red;"' : '';
                    return `<li ${style}>${index + 1}ä½: ${entry.name}ï¼ˆ${entry.score} ãƒšã‚¢ï¼‰</li>`;
                })
                .join(""); // <li>è¦ç´ ã®æ–‡å­—åˆ—ã‚’çµåˆ

            // æœ€çµ‚çš„ãªãƒªã‚¹ãƒˆã‚’ finalScore ã®è¦ç´ ã«æŒ¿å…¥
            finalScoreEl.innerHTML = `<ul>${rankingList}</ul>`;

            // æ–‡å­—ã‚’å¤§ããã™ã‚‹ã‚¹ã‚¿ã‚¤ãƒ«
            finalScoreEl.style.fontSize = "24px"; // ã‚µã‚¤ã‚ºèª¿æ•´
            finalScoreEl.style.lineHeight = "1.5"; // è¡Œé–“ã®èª¿æ•´
            finalScoreEl.style.listStyleType = "none"; // é»’ç‚¹ã‚’é™¤å»
            finalScoreEl.style.paddingLeft = "20px"; // å·¦ã«ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¿½åŠ ã—ã¦ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ
            finalScoreEl.style.color = "#333"; // æ–‡å­—ã®è‰²ã‚’å¤‰æ›´

            // ul è¦ç´ ã‚’å·¦æƒãˆ
            const ul = finalScoreEl.querySelector('ul');
            ul.style.textAlign = 'left'; // å·¦æƒãˆ
            document.getElementById("gameOverModal").style.display = "flex";
        }




        async function restartGame() {
            document.getElementById("gameOverModal").style.display = "none";
            document.getElementById("gameBoard").style.display = "none";
            document.querySelector(".score-board").style.display = "none";
            document.querySelector(".current-Player").style.display = "none";
            document.getElementById("gameIdDisplay").style.display = "block"
            document.getElementById("lobbySection").style.display = "block";

            await db.collection("games").doc(gameId).update({
                started: false,
                flipped: [],
                matchedIndices: [],
            });

        }



        async function exitGame() {
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±ã‚’ã™ã¹ã¦å‰Šé™¤
            const playersRef = db.collection("games").doc(gameId).collection("players");
            const playersSnapshot = await playersRef.get();
            const deletePromises = playersSnapshot.docs.map(doc => doc.ref.delete());
            await Promise.all(deletePromises);

            // ã‚²ãƒ¼ãƒ ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‰Šé™¤
            await db.collection("games").doc(gameId).delete();
            location.reload();
        }

    </script>
</body>

</html>