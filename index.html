<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ç¥çµŒè¡°å¼±</title>
    <style>
        #gameBoard {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            padding: 20px;
            background-image: url('./ground.jpg');
            /* èƒŒæ™¯ç”»åƒã®ãƒ‘ã‚¹ */
            background-size: cover;
            background-position: center;
        }


        .card {
            aspect-ratio: 5 / 7;
            width: 100%;
            border: 2px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgb(141, 140, 140);
            cursor: pointer;
        }

        #playerList li {
            font-size: 20px;
            /* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒãƒ¼ãƒ ã®æ–‡å­—ã‚µã‚¤ã‚ºã‚’å¤§ããã™ã‚‹ */
            font-weight: bold;
            /* å¤ªå­—ã«ã™ã‚‹ */
            margin-bottom: 10px;
        }

        #buttonContainer {
            display: flex;
            gap: 10px;
            /* ãƒœã‚¿ãƒ³é–“ã®ã‚¹ãƒšãƒ¼ã‚¹ */
            justify-content: center;
            /* ãƒœã‚¿ãƒ³ã‚’ä¸­å¤®æƒãˆ */
            margin-top: 30px;
            /* ä¸Šéƒ¨ã«ä½™ç™½ã‚’è¿½åŠ  */
        }

        #startGameBtn,
        #cardsBtn,
        #retireGameBtn {
            font-size: 18px;
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
        }

        #startGameBtn {
            background-color: #4CAF50;
            color: white;
        }

        #cardsBtn {
            background-color: #2196F3;
            color: white;
        }

        #retireGameBtn {
            background-color: #f44336;
            color: white;
        }



        #startGameBtn:disabled,
        #cardsBtn:disabled,
        #retireGameBtn:disabled {
            background-color: #aaa;
            cursor: not-allowed;
        }



        .flipped {
            background-color: white;
        }

        .score-board {
            margin-top: 20px;
            text-align: center;
            font-size: 20px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
        }

        .effect-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.3s ease;
        }

        .effect-modal img {
            width: 200px;
            height: auto;
            margin-bottom: 20px;
        }

        .effect-modal.hidden {
            display: none;
        }

        #effectText {
            font-size: 32px;
            /* æ–‡å­—ã‚’å¤§ãã */
            color: #00aaff;
            /* é’ç³»ã®ã‚«ãƒ©ãƒ¼ã« */
            text-align: center;
            /* ä¸­å¤®æƒãˆ */
            font-weight: bold;
            /* å¤ªå­—ã«ã—ã¦è¦‹ã‚„ã™ã */
            margin-top: 10px;
            /* ç”»åƒã¨ã®ä½™ç™½ */
        }

        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .start-menu {
            text-align: center;
            margin-top: 50px;
        }




        #gameBoard,
        .score-board,
        .current-Player {
            display: none;
        }

        .highlight-red {
            border: 3px solid red;
            box-shadow: 0 0 10px red;
            transition: all 0.3s;
        }

        .card-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 16px;
            justify-items: center;
            margin-top: 20px;
        }

        .card-wrapper {
            width: 100%;
            max-width: 150px;
            text-align: center;
        }

        .card-wrapper img {
            width: 100%;
            height: auto;
            object-fit: contain;
        }

        .card-wrapper label,
        .card-wrapper input {
            display: block;
            margin-top: 8px;
        }

        /* ãƒœã‚¿ãƒ³ã‚¹ã‚¿ã‚¤ãƒ« */
        #confirmCardBtn {
            margin-top: 30px;
            padding: 12px 24px;
            font-size: 20px;
            background-color: #4CAF50;
            /* ç·‘ */
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s;
            width: 80%;
            max-width: 300px;
        }

        #cardSelectionForm button:hover {
            background-color: #5a1488;
        }

        /* ã‚¹ãƒãƒ›ç”»é¢ç”¨ã®èª¿æ•´ */
        @media (max-width: 600px) {
            .card-container {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            }

            #cardSelectionForm button {
                font-size: 18px;
                padding: 10px 20px;
                width: 90%;
            }
        }


        /* ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤ãƒœã‚¿ãƒ³ */
        #restartButton {
            background: linear-gradient(45deg, #6e7e80, #4c5c63);
            /* ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ */
            color: white;
            padding: 15px 30px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            /* ä¸¸ã„è§’ */
            cursor: pointer;
            transition: transform 0.2s, background-color 0.3s ease;
            /* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
            box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.2);
            /* ã‚·ãƒ£ãƒ‰ã‚¦ */
        }

        /* çµ‚äº†ãƒœã‚¿ãƒ³ */
        #exitButton {
            background: linear-gradient(45deg, #f44336, #ff9800);
            /* èµ¤ã‚ªãƒ¬ãƒ³ã‚¸ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ */
            color: white;
            padding: 15px 30px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            /* ä¸¸ã„è§’ */
            cursor: pointer;
            transition: transform 0.2s, background-color 0.3s ease;
            /* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
            box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.2);
            /* ã‚·ãƒ£ãƒ‰ã‚¦ */
        }

        /* ãƒ›ãƒãƒ¼æ™‚ã«è‰²ã‚’å¤‰æ›´ */
        #restartButton:hover {
            background: linear-gradient(45deg, #5a6b74, #3f4f57);
            /* å°‘ã—æ¿ƒã„è‰² */
            transform: translateY(-4px);
            /* ä¸Šã«æµ®ã‹ã›ã‚‹ */
        }

        #exitButton:hover {
            background: linear-gradient(45deg, #e53935, #f57c00);
            /* çµ‚äº†ãƒœã‚¿ãƒ³ã®è‰²å¤‰æ›´ */
            transform: translateY(-4px);
            /* ä¸Šã«æµ®ã‹ã›ã‚‹ */
        }

        /* ã‚¯ãƒªãƒƒã‚¯æ™‚ã«å°‘ã—ç¸®ã‚€ */
        button:active {
            transform: scale(0.98);
        }

        /* confirmCardBtn ã®ã¿ã«é©ç”¨ */
        #startGameBtn:disabled {
            cursor: not-allowed;
            /* ç¦æ­¢ã‚«ãƒ¼ã‚½ãƒ« */
            background-color: #ccc;
            /* ãƒœã‚¿ãƒ³ã®èƒŒæ™¯è‰²ã‚’å¤‰æ›´ */
            color: #666;
            /* ãƒœã‚¿ãƒ³ã®æ–‡å­—è‰²ã‚’å¤‰æ›´ */
            border: 1px solid #999;
            /* æ ç·šã‚’å¤‰æ›´ */
        }

        /* ãƒœã‚¿ãƒ³ãŒç„¡åŠ¹ã«ãªã£ãŸã¨ãã€ãƒã‚¦ã‚¹ã‚ªãƒ¼ãƒãƒ¼æ™‚ã«ã‚«ãƒ¼ã‚½ãƒ«ã‚’ç¦æ­¢ã«å¤‰æ›´ */
        /* confirmCardBtn ã®ã¿ã«é©ç”¨ */
        #confirmCardBtn:disabled {
            cursor: not-allowed;
            /* ç¦æ­¢ã‚«ãƒ¼ã‚½ãƒ« */
            background-color: #ccc;
            /* ãƒœã‚¿ãƒ³ã®èƒŒæ™¯è‰²ã‚’å¤‰æ›´ */
            color: #2b2323;
            /* ãƒœã‚¿ãƒ³ã®æ–‡å­—è‰²ã‚’å¤‰æ›´ */
            border: 1px solid #999;
            /* æ ç·šã‚’å¤‰æ›´ */
        }
    </style>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
</head>

<body>

    <!-- ã‚²ãƒ¼ãƒ å‚åŠ ç”»é¢ -->
    <div id="joinGameSection">
        <h2>ã‚²ãƒ¼ãƒ ã«å‚åŠ </h2>
        <input type="text" id="gameIdInput" placeholder="ã‚²ãƒ¼ãƒ IDã‚’å…¥åŠ›">
        <button onclick="joinGame()">æ¬¡ã¸</button>
    </div>

    <!-- åå‰å…¥åŠ› -->
    <div id="nameInputSection" style="display:none;">
        <h2>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åã‚’å…¥åŠ›</h2>
        <input type="text" id="playerNameInput" placeholder="åå‰">
        <button onclick="enterLobby()">ãƒ­ãƒ“ãƒ¼ã«å‚åŠ </button>
    </div>

    <!-- ãƒ­ãƒ“ãƒ¼ -->
    <div id="lobbySection" style="display:none;">
        <h2>å¾…æ©Ÿä¸­ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</h2>
        <ul id="playerList"></ul>
        <button id="startGameBtn" onclick="startGameInLobby()" disabled>ã‚²ãƒ¼ãƒ é–‹å§‹</button>
        <button id="cardsBtn" onclick="requestCardSelection()">ã‚«ãƒ¼ãƒ‰é¸æŠ</button>
        <button id="retireGameBtn" onclick="leaveGame()">æŠœã‘ã‚‹</button>
    </div>
    <div id="gameIdDisplay" style="margin-top: 10px; font-size: 18px; font-weight: bold;"></div>



    <!-- ã‚²ãƒ¼ãƒ ç”»é¢ -->
    <div class="current-Player">
        <div id="currentPlayer"></div>
    </div>
    <div class="game-board" id="gameBoard"></div>
    <div class="score-board">
        <div id="scores"></div>
    </div>
    <div id="gameOverModal" class="modal">
        <div class="modal-content">
            <h2>ã‚²ãƒ¼ãƒ çµ‚äº†ï¼</h2>
            <p id="finalScore"></p>
            <button id="restartButton" onclick="restartGame()">ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤</button>
            <button id="exitButton" onclick="leaveGame()">çµ‚äº†</button>

        </div>
    </div>
    <div id="effectModal" class="effect-modal hidden">
        <img id="effectImage" src="" alt="Card Image" />
        <div id="effectText"></div>
    </div>
    <div id="cardSelectionSection" style="display: none;">
        <h3>ã‚«ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„</h3>
        <form id="cardSelectionForm" onsubmit="return false;">
            <div id="cardSelectionContainer" class="card-container"></div>
            <div style="margin-top: 10px; display: flex; align-items: center; gap: 10px;">
                <button id="confirmCardBtn" onclick="backlobby()" disabled>ã‚«ãƒ¼ãƒ‰ã‚’æ±ºå®š</button>
            </div>

        </form>
    </div>




    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyBvjSDUh-IaCZQ17bE3Q4IfI0yZDqbDcz0",
            authDomain: "flipcards-5ca31.firebaseapp.com",
            projectId: "flipcards-5ca31",
            storageBucket: "flipcards-5ca31.appspot.com",
            messagingSenderId: "599139871804",
            appId: "1:599139871804:web:5402c51a0acfd75cd36739",
            measurementId: "G-KB8ZCG0HG8"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        let gameId = "";
        let playerName = "";
        let myplayerName = "";
        let currentPlayer = 1;
        let PName = {};
        let numPlayers = 0;
        let playerId = "";
        let skipdata = 0;
        let generatedCards = [];
        let cards = [];
        let selectedCards = [];
        let cardImages = {
            "bomb": "bomb.png",
            "special": "special.png",
            "skip": "skip.png",
            "devil": "devil.png",
            "angel": "angel.png",
            "thief": "thief.png",
            "king": "king.png",
            "revo": "revo.png",
            "heart": "heart.png",
            "crowbar": "crowbar.png",
            "diamond": "diamond.png",
            "spade": "spade.png",
            "karaage": "karaage.png",
            "elf": "elf.png",
            "1": "1.png",
            "2": "2.png",
            "3": "3.png",
            "tunami": "tunami.png",
            "quake": "quake.png",
        };
        let isThiefMode = false;        // æ³¥æ£’åŠ¹æœä¸­ã‹ã©ã†ã‹
        let resolveThiefSelect = null;
        let selectedThiefIndex = null;
        const specialTypes = ["heart", "crowbar", "diamond", "spade"];
        const originalCardImages = {
            heart: "heart.png",
            crowbar: "crowbar.png",
            diamond: "diamond.png",
            spade: "spade.png",
        };
        let lastEffectTimestamp = 0;
        let selectedspecialIndex = null;
        let originalSpecialCards = []; // å…ƒã®çŠ¶æ…‹ä¿å­˜ç”¨
        let isKaraageMode = false;
        let karaageEffect = false;
        let finishkaraageEffect = false;
        let scores = {};
        let flippedCards = [];
        let lastSeenEffectKey = "";

        async function checkIfHost() {
            const playerDoc = await db.collection("games")
                .doc(gameId)
                .collection("players")
                .doc(playerId)
                .get();

            const data = playerDoc.data();
            if (data && data.isHost) {
                document.getElementById("startGameBtn").disabled = false;
                document.getElementById("confirmCardBtn").disabled = false;
            } else {
                document.getElementById("startGameBtn").disabled = true;
                document.getElementById("confirmCardBtn").disabled = true;
            }
        }



        function joinGame() {
            gameId = document.getElementById("gameIdInput").value.trim();
            if (!gameId) return alert("ã‚²ãƒ¼ãƒ IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
            document.getElementById("joinGameSection").style.display = "none";
            document.getElementById("nameInputSection").style.display = "block";
        }

        async function enterLobby() {
            playerName = document.getElementById("playerNameInput").value.trim();
            if (!playerName) return alert("åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");

            const gameRef = db.collection("games").doc(gameId);
            const playersRef = gameRef.collection("players");

            const gameSnap = await gameRef.get();
            const gameData = gameSnap.data();

            // ã‚²ãƒ¼ãƒ ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’ä½œæˆãƒ»æ›´æ–°ï¼ˆstarted ãƒ•ãƒ©ã‚°ã¯åˆæœŸ falseï¼‰
            if (!gameData || gameData.started === undefined) {
                await gameRef.set({ started: false }, { merge: true });
            }

            // åŒã˜åå‰ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã™ã§ã«å­˜åœ¨ã™ã‚‹ã‹ç¢ºèªï¼ˆå¾©å¸°å¯¾å¿œï¼‰
            const snapshot = await playersRef.where("name", "==", playerName).get();

            if (!snapshot.empty) {
                // å†æ¥ç¶š: æ—¢å­˜ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã—ã¦ playerId ã‚’å–å¾—
                playerId = snapshot.docs[0].id;
            } else {
                // æ–°è¦ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½œæˆ
                playerId = `player_${Date.now()}`;
                const allPlayersSnap = await playersRef.get();
                isHost = allPlayersSnap.empty;

                await playersRef.doc(playerId).set({
                    name: playerName,
                    isHost: isHost
                });

                if (isHost) {
                    await updateHostStatus();
                }
            }

            await checkIfHost();
            listenToCardSelectionStatus();
            listenToLobby(); // ãƒ­ãƒ“ãƒ¼è¡¨ç¤ºãƒ»æ›´æ–°

            // ğŸ”¥ ã“ã“ã§ã‚²ãƒ¼ãƒ ãŒå§‹ã¾ã£ã¦ã„ãŸã‚‰ã€å³ã‚²ãƒ¼ãƒ ç”»é¢ã«å¾©å¸°
            if (gameData && gameData.started) {

                // å¾©å¸°ï¼šã‚²ãƒ¼ãƒ ç”»é¢ã¸ç§»è¡Œ
                document.getElementById("nameInputSection").style.display = "none";
                document.getElementById("lobbySection").style.display = "none";
                startGame(); // â† ã“ã®é–¢æ•°ã§ listenToGameState ãªã©ãŒå‘¼ã°ã‚Œã‚‹æƒ³å®š
            } else {
                // é€šå¸¸ãƒ­ãƒ“ãƒ¼è¡¨ç¤º
                document.getElementById("nameInputSection").style.display = "none";
                document.getElementById("lobbySection").style.display = "block";
            }
        }



        async function updateHostStatus() {
            const gameRef = db.collection("games").doc(gameId);
            const playersRef = gameRef.collection("players");

            // ã‚²ãƒ¼ãƒ å†…ã§ã¾ã ãƒ›ã‚¹ãƒˆãŒã„ãªã„å ´åˆã€æœ€åˆã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ãƒ›ã‚¹ãƒˆæ¨©é™ã‚’ä»˜ä¸
            const snapshot = await playersRef.get();
            if (snapshot.empty) return;

            const nextHost = snapshot.docs[0];
            await nextHost.ref.update({ isHost: true });
        }

        function listenToLobby() {
            const playerListEl = document.getElementById("playerList");
            document.getElementById("gameIdDisplay").textContent = `ã‚²ãƒ¼ãƒ ID: ${gameId}`;
            db.collection("games").doc(gameId).collection("players").onSnapshot(snapshot => {
                playerListEl.innerHTML = "";
                numPlayers = snapshot.size;
                snapshot.forEach(doc => {
                    const li = document.createElement("li");
                    li.textContent = doc.data().name;
                    playerListEl.appendChild(li);
                });
                // ãƒœã‚¿ãƒ³ã®æœ‰åŠ¹ç„¡åŠ¹ã‚’æ­£ã—ãåˆ‡ã‚Šæ›¿ãˆã‚‹
                checkIfHost();
            });

            db.collection("games").doc(gameId).onSnapshot(doc => {
                if (doc.data().started) {
                    startGame();
                }
            });
        }
        async function requestCardSelection() {
            event.preventDefault();
            await db.collection("games").doc(gameId).set({
                selectedCards: [],
                selectingCards: true,
            });
        }

        // ãƒ­ãƒ“ãƒ¼ç”»é¢ã«ã‚«ãƒ¼ãƒ‰é¸æŠã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¡¨ç¤º
        async function showCardSelection() {
            // è¡¨ç¤ºç”¨ã®ã‚«ãƒ¼ãƒ‰ãƒªã‚¹ãƒˆ
            const cards = [
                "1", "2", "3",
                "heart", "crowbar", "diamond", "spade",
                "bomb", "special",
                "skip", "devil",
                "angel", "thief",
                "king", "revo", "elf", "tunami", "quake", "random",
            ];

            const cardSelectionContainer = document.getElementById("cardSelectionContainer");
            cardSelectionContainer.innerHTML = "";
            // å„ã‚«ãƒ¼ãƒ‰ã«å¯¾å¿œã™ã‚‹ç”»åƒã¨å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ä½œæˆ
            cards.forEach(card => {
                // ã‚«ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã®ãƒ©ãƒƒãƒ‘ãƒ¼ã‚’ä½œæˆ
                const cardWrapper = document.createElement("div");
                cardWrapper.classList.add("card-wrapper");

                // ç”»åƒã‚’ä½œæˆï¼ˆç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã¯é©å®œç½®ãæ›ãˆã¦ãã ã•ã„ï¼‰
                const img = document.createElement("img");
                img.src = `${card}.png`;  // ä¾‹: images/1.png, images/heart.png
                img.alt = card;

                // ãƒšã‚¢æ•°ã‚’é¸æŠã™ã‚‹å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ä½œæˆ
                const label = document.createElement("label");
                label.textContent = `${card} ãƒšã‚¢æ•°: `;

                const input = document.createElement("input");
                input.type = "number";  // æ•°å€¤ã®å…¥åŠ›
                input.name = card;      // åå‰ã‚’ã‚«ãƒ¼ãƒ‰åã«è¨­å®š
                input.value = "0";      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒšã‚¢æ•°ã¯ 0
                input.min = "0";        // 0 ä»¥ä¸‹ã®æ•°å€¤ã¯é¸ã¹ãªã„ã‚ˆã†ã«
                input.max = "10";       // ä»»æ„ã®æœ€å¤§æ•°å€¤ï¼ˆä¾‹ãˆã°10ãƒšã‚¢ã¾ã§ï¼‰
                input.step = "1";       // 1å˜ä½ã§å¤‰æ›´ã§ãã‚‹ã‚ˆã†ã«è¨­å®š

                // ã‚«ãƒ¼ãƒ‰ç”»åƒã¨ãƒšã‚¢æ•°é¸æŠã‚’ãƒ©ãƒƒãƒ—ã™ã‚‹
                cardWrapper.appendChild(img);
                cardWrapper.appendChild(label);
                cardWrapper.appendChild(input);

                // ã‚³ãƒ³ãƒ†ãƒŠã«ã‚«ãƒ¼ãƒ‰ã‚’è¿½åŠ 
                cardSelectionContainer.appendChild(cardWrapper);
            });
            document.getElementById("cardSelectionSection").style.display = "block";
            document.getElementById("lobbySection").style.display = "none";
        }

        function generateRandomCards(randomPairs) {
            const cards = [
                "1", "2", "3",
                "heart", "crowbar", "diamond", "spade",
                "bomb", "special",
                "skip", "devil",
                "angel", "thief",
                "king", "revo", "elf", "tunami", "quake",
            ];
            const selected = [];
            // æœ€åˆã«1å›ã ã‘ã‚·ãƒ£ãƒƒãƒ•ãƒ«
            shuffle(cards);
            let i = 0;
            const rcards = cards
            while (selected.length < randomPairs * 2) {
                const card = rcards[i % rcards.length]; // ãƒªã‚¹ãƒˆã‚’ç¹°ã‚Šè¿”ã—ä½¿ã†
                if (Math.random() < 0.5) {
                    selected.push(card, card);
                    while (Math.random() < 0.30 && selected.length < randomPairs * 2) {
                        selected.push(card, card);
                    }
                }
                i++;
            }
            console.log(selected);
            return selected;
        }



        function listenToCardSelectionStatus() {
            db.collection("games").doc(gameId).onSnapshot(doc => {
                const data = doc.data();
                if (data?.selectingCards) {
                    // selectingCardsãŒtrueãªã‚‰ã‚«ãƒ¼ãƒ‰é¸æŠç”»é¢ã¸
                    showCardSelection();
                } else {
                    // selectingCardsãŒfalseãªã‚‰ãƒ­ãƒ“ãƒ¼ç”»é¢ã¸
                    document.getElementById("cardSelectionSection").style.display = "none";
                    document.getElementById("lobbySection").style.display = "block";
                }
            });
        }
        async function backlobby() {
            event.preventDefault();
            await handleCardSelection(event)
            selectedCards = [];
            const container = document.getElementById("cardSelectionContainer");
            container.innerHTML = "";
            const form = document.getElementById("cardSelectionForm");
            form.reset();
            document.getElementById("cardSelectionSection").style.display = "none";
            document.getElementById("lobbySection").style.display = "block";
        }

        // ã‚«ãƒ¼ãƒ‰é¸æŠãƒ•ã‚©ãƒ¼ãƒ ãŒé€ä¿¡ã•ã‚ŒãŸéš›ã«å‘¼ã°ã‚Œã‚‹
        async function handleCardSelection(event) {
            event.preventDefault();
            const cardInputs = document.querySelectorAll("input[type='number']");
            const selectedCards = [];
            let randomPairs = 0;

            cardInputs.forEach(input => {
                const cardName = input.name;
                const pairCount = parseInt(input.value);
                if (pairCount > 0) {
                    if (cardName === "random") {
                        randomPairs += pairCount;
                    } else {
                        for (let i = 0; i < pairCount; i++) {
                            selectedCards.push(cardName, cardName);
                        }
                    }
                }
            });

            // ãƒ©ãƒ³ãƒ€ãƒ åˆ†ã‚’è¿½åŠ 
            if (randomPairs > 0) {
                const generated = generateRandomCards(randomPairs);
                selectedCards.push(...generated);
            }
            console.log(selectedCards);

            await db.collection("games").doc(gameId).update({
                selectingCards: false,
                selectedCards: selectedCards,
            });
        }





        async function startGameInLobby() {
            // selectedCardsã‚’Firebaseã‹ã‚‰å–å¾—
            const gameDoc = await db.collection("games").doc(gameId).get();
            const data = gameDoc.data();
            if (data && data.selectedCards) {
                // ã“ã“ã§cardsã«selectedCardsã‚’ã‚³ãƒ”ãƒ¼ï¼
                cards = [...data.selectedCards];
                shuffle(cards);
                const playerSnapshot = await db.collection("games").doc(gameId).collection("players").get();
                const playersArray = playerSnapshot.docs.map(doc => ({
                    id: doc.id,
                    name: doc.data().name
                }));

                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é †ç•ªã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«ã™ã‚‹
                shuffle(playersArray);
                let scoresObj = {};
                let Name = {};
                playersArray.forEach((player, index) => {
                    const playerIndex = index + 1;
                    scoresObj[playerIndex] = 0;
                    Name[playerIndex] = player.name;
                });

                await db.collection("games").doc(gameId).set({
                    cards: cards,
                    currentPlayer: 1,
                    PName: Name,
                    scores: scoresObj,
                    flipped: [],
                    matchedIndices: [],
                    skippedPlayers: [],
                    started: true
                }, { merge: true });


            }
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        function shuffleRemainingCardsOnly(cards, matchedIndices, flipped, includeFlipped = false) {
            const totalIndices = [...Array(cards.length).keys()];

            // includeFlipped ã«å¿œã˜ã¦ã‚·ãƒ£ãƒƒãƒ•ãƒ«å¯¾è±¡ã‚’æ±ºå®š
            const fixedIndices = includeFlipped
                ? new Set([...matchedIndices])
                : new Set([...matchedIndices, ...flipped]);

            const toShuffleIndices = totalIndices.filter(i => !fixedIndices.has(i));

            const toShuffleCards = toShuffleIndices.map(i => cards[i]);

            // Fisher-Yates ã‚·ãƒ£ãƒƒãƒ•ãƒ«
            for (let i = toShuffleCards.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [toShuffleCards[i], toShuffleCards[j]] = [toShuffleCards[j], toShuffleCards[i]];
            }

            toShuffleIndices.forEach((idx, i) => {
                cards[idx] = toShuffleCards[i];
            });
        }


        function startGame() {
            document.getElementById("lobbySection").style.display = "none";
            document.getElementById("gameIdDisplay").style.display = "none";
            document.getElementById("gameBoard").style.display = "grid";
            document.querySelector(".score-board").style.display = "block";
            document.querySelector(".current-Player").style.display = "block";
            EFFECT();
            SpecialEffects();
            checkGameOver();
            listenToGameState();
        }

        let gameStateUnsubscribe = null;
        function listenToGameState() {
            if (gameStateUnsubscribe) return;

            gameStateUnsubscribe = db.collection("games").doc(gameId).onSnapshot(doc => {
                const data = doc.data();
                if (!data) return;
                cards = data.cards;
                PName = data.PName; // â† typoã«æ³¨æ„ï¼ï¼ˆPname â†’ PNameï¼‰
                scores = data.scores;
                currentPlayer = data.currentPlayer;
                flippedCards = data.flipped;
                const matched = data.matchedIndices || [];
                const highlighted = data.highlightedIndices || [];

                renderBoard(cards, flippedCards, matched, highlighted, currentPlayer, PName);

                if (data.cardImages) {
                    cardImages = data.cardImages;
                    updateCardImagesOnScreen();
                }

                updateSP();
            });
        }

        const cardStyles = {};
        function renderBoard(cards, flipped, matched, highlighted, currentPlayerNum, PName) {
            const gameBoard = document.getElementById("gameBoard");
            const scoreBoard = document.getElementById("scores");
            gameBoard.innerHTML = "";
            scoreBoard.innerHTML = "";
            // ãƒ©ãƒ³ãƒ€ãƒ ãª border-radius ã®å€™è£œï¼ˆè§’ã®ä¸¸ã¿ï¼‰
            const shapes = ["0%", "10%", "25%", "50%"];


            cards.forEach((value, index) => {
                const card = document.createElement("div");
                card.className = "card";
                card.dataset.index = index;
                card.dataset.value = value;

                if (!cardStyles[index]) {
                    cardStyles[index] = {
                        shape: shapes[Math.floor(Math.random() * shapes.length)],
                    };
                }
                // ä¿å­˜ã•ã‚ŒãŸã‚¹ã‚¿ã‚¤ãƒ«ã‚’é©ç”¨
                card.style.borderRadius = cardStyles[index].shape;

                if (highlighted.includes(index)) {
                    card.classList.add("highlight-red");
                }

                if (flipped.includes(index) || matched.includes(index)) {
                    card.classList.add("flipped");
                    const img = document.createElement("img");
                    const src = cardImages[value];
                    if (src) {
                        img.src = `./${src}`;
                        img.alt = value;
                        img.style.width = "100%";
                        img.style.height = "100%";
                        card.appendChild(img);
                    }
                }

                if (
                    playerName === PName[currentPlayerNum] &&
                    !matched.includes(index) &&
                    !flipped.includes(index)
                ) {
                    card.addEventListener("click", () => handleCardClick(card));
                }

                gameBoard.appendChild(card);
            });
        }

        function updateCardImagesOnScreen() {
            document.querySelectorAll(".card.flipped img").forEach(img => {
                const cardDiv = img.parentElement;
                const value = cardDiv.dataset.value;
                const newSrc = cardImages[value];
                if (newSrc) {
                    img.src = `./${newSrc}`;
                }
            });
        }



        let isProcessing = false;

        async function handleCardClick(card) {
            if (isProcessing) return; // ãƒ­ãƒƒã‚¯ä¸­ãªã‚‰ä½•ã‚‚ã—ãªã„
            isProcessing = true;
            const index = parseInt(card.dataset.index);
            const doc = await db.collection("games").doc(gameId).get();  // ã‚²ãƒ¼ãƒ ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å–å¾—
            const data = doc.data();
            const matched = data.matchedIndices || [];

            // æ³¥æ£’åŠ¹æœä¸­ãªã‚‰ç‰¹åˆ¥ãªå‡¦ç†
            if (isThiefMode || isKaraageMode) {
                const index = parseInt(card.dataset.index);
                // è¡¨ or matchedã‚«ãƒ¼ãƒ‰ã¯ç„¡è¦–
                if (data.flipped.includes(index) || matched.includes(index)) return;

                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé¸ã‚“ã ã‚«ãƒ¼ãƒ‰ã‚’ä¿å­˜
                if (isThiefMode) selectedThiefIndex = index;
                if (isKaraageMode) selectedspecialIndex = index;

                const newFlipped = [...data.flipped, index];
                await db.collection("games").doc(gameId).update({ flipped: newFlipped });
                if (resolveThiefSelect) resolveThiefSelect(); // ğŸ‘ˆ Promise è§£æ±º
                return;
            }

            data.flipped.push(index);
            await bombeffect(index, data, gameId, cards);
            await db.collection("games").doc(gameId).update({
                flipped: data.flipped,
                highlightedIndices: data.flipped
            }, { merge: true });
            if (data.flipped.length === 2) {
                const card1 = cards[data.flipped[0]];
                const card2 = cards[data.flipped[1]];
                if (card1 === card2) {
                    await triggerCardEffect(card1, data);
                    const docment = await db.collection("games").doc(gameId).get();  // ã‚²ãƒ¼ãƒ ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å–å¾—
                    const updata = docment.data(); // é€šå¸¸ã®ä¸€è‡´ã—ãŸã‚«ãƒ¼ãƒ‰åã‚’æ¸¡ã™
                    const newMatched = [...(updata.matchedIndices || []), ...updata.flipped];
                    await new Promise(resolve => setTimeout(resolve, 500));
                    await db.collection("games").doc(gameId).update({
                        currentPlayer: currentPlayer,
                        scores: scores,
                        flipped: [],
                        highlightedIndices: [],
                        noMatchPlayers: [],
                        matchedIndices: newMatched,
                    });
                    await checkGameOver();
                    isProcessing = false;
                } else {
                    setTimeout(async () => {
                        const gameRef = db.collection("games").doc(gameId);
                        const latestDoc = await gameRef.get();
                        const latestData = latestDoc.data();
                        const matched = latestData.matchedIndices || [];
                        const currentCards = [...latestData.cards]; // â† Firestoreã®cardsã‚’å–å¾—
                        const remaining = currentCards.length - matched.length;

                        let nextPlayer;
                        const extraTurnAfterMiss = latestData.extraTurnAfterMiss;
                        if (extraTurnAfterMiss === currentPlayer) {
                            nextPlayer = currentPlayer;
                            skipEffect();
                            await gameRef.update({ extraTurnAfterMiss: null }); // ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
                        } else {
                            nextPlayer = await getNextPlayer(currentPlayer, numPlayers, latestData, gameId);
                        }
                        if (remaining <= 6) {
                            const updatedNoMatch = Array.from(new Set([...(latestData.noMatchPlayers || []), currentPlayer]));

                            // ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã‚«ã‚¦ãƒ³ãƒˆãŒã¾ã è¨­å®šã•ã‚Œã¦ã„ãªã„ã‹ç¢ºèª
                            const hasShuffleCounter = latestData.shuffleDelayCounter !== undefined;

                            // ä¸€å‘¨åˆ†ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒãƒŸã‚¹ã—ãŸå¾Œ
                            if (updatedNoMatch.length >= numPlayers && !hasShuffleCounter) {
                                // 0ã€œ(numPlayers - 1) ã®ãƒ©ãƒ³ãƒ€ãƒ ãªé…å»¶ã‚’ã‚»ãƒƒãƒˆ
                                const randomDelay = Math.floor(Math.random() * numPlayers);
                                await gameRef.update({
                                    noMatchPlayers: updatedNoMatch,
                                    shuffleDelayCounter: randomDelay
                                });
                            } else {
                                // ã¾ã ä¸€å‘¨ã—ã¦ã„ãªã„ or ã‚«ã‚¦ãƒ³ãƒˆä¸­
                                await gameRef.update({
                                    noMatchPlayers: updatedNoMatch
                                });
                            }
                        }
                        if (remaining <= 6 && latestData.shuffleDelayCounter !== undefined) {
                            if (latestData.shuffleDelayCounter <= 0) {
                                // ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã‚’å®Ÿè¡Œ
                                shuffleRemainingCardsOnly(currentCards, matched, latestData.flipped, true);
                                elfEffect();

                                await gameRef.update({
                                    cards: currentCards, // ã‚·ãƒ£ãƒƒãƒ•ãƒ«å¾Œã®ã‚«ãƒ¼ãƒ‰
                                    noMatchPlayers: [],
                                    shuffleDelayCounter: firebase.firestore.FieldValue.delete() // ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼å‰Šé™¤
                                });
                            } else {
                                // ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã‚«ã‚¦ãƒ³ãƒˆã‚’1æ¸›ã‚‰ã™
                                await gameRef.update({
                                    shuffleDelayCounter: latestData.shuffleDelayCounter - 1
                                });
                            }
                        }

                        await new Promise(resolve => setTimeout(resolve, 500));
                        await gameRef.update({
                            currentPlayer: nextPlayer,
                            flipped: [],
                            highlightedIndices: []
                        });

                        isProcessing = false;
                    }, 1000);
                }
            } else {
                isProcessing = false;
            }
        }
        async function bombeffect(index, data, gameId, cards) {
            scores[currentPlayer] = 0;
            if (Math.random() < 0.3) {
                // 80%: è‡ªåˆ†ã®ã‚¹ã‚³ã‚¢ã‚’0ã«
                for (let player in scores) {
                    scores[player] = Math.max(0, scores[player] - 2);
                }
            }
            // 20%: å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ã‚³ã‚¢ã‚’-1ï¼ˆãŸã ã—0æœªæº€ã«ã¯ã—ãªã„ï¼‰

            if (cards[index] === "bomb") {
                const matched = data.matchedIndices || [];

                // ä»–ã®æœªç™ºè¦‹ã®bombã‚’æ¢ã—ã¦è¿½åŠ 
                const remainingBombs = cards
                    .map((val, idx) => ({ val, idx }))
                    .filter(obj =>
                        obj.val === "bomb" &&
                        !data.flipped.includes(obj.idx) &&
                        !matched.includes(obj.idx) &&
                        obj.idx !== index // ä»Šå›ã‚ãã£ãŸ bomb è‡ªä½“ã¯é™¤ã
                    );

                if (remainingBombs.length > 0) {
                    const randomBomb = remainingBombs[Math.floor(Math.random() * remainingBombs.length)];
                    data.flipped.push(randomBomb.idx);
                }

                // 3æšã‚ãã‚‰ã‚ŒãŸå ´åˆã€æœ€åˆã®ã‚«ãƒ¼ãƒ‰ï¼ˆébombï¼‰ã‚’è£è¿”ã™
                if (data.flipped.length === 3) {
                    data.flipped.splice(0, 1); // æœ€åˆã®1æšã‚’å‰Šé™¤

                }
                await db.collection("games").doc(gameId).update({
                    flipped: data.flipped,
                    scores: scores,
                });
            }
        }
        async function getNextPlayer(currentPlayer, numPlayers, data, gameId) {
            let next = currentPlayer;
            do {
                next = next % numPlayers + 1;
                const gameDoc = await db.collection("games").doc(gameId).get();
                const updatedData = gameDoc.data();
                const skippedPlayers = updatedData.skippedPlayers || [];

                if (skippedPlayers.includes(next)) {
                    if (Math.random() < 0.6) {
                        // Firebaseã®DBã‹ã‚‰ã‚‚å‰Šé™¤
                        await db.collection("games").doc(gameId).update({
                            skippedPlayers: firebase.firestore.FieldValue.arrayRemove(next)
                        });
                    }
                    else {
                        devilEffect();
                    }

                    // æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ¢ã™ãŸã‚ continue
                    continue;
                }

                break; // ã‚¹ã‚­ãƒƒãƒ—å¯¾è±¡ã§ãªã„å ´åˆã¯ãƒ«ãƒ¼ãƒ—çµ‚äº†

            } while (true);
            return next;  // æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¿”ã™

        }

        async function thiefEffect() {
            const doc = await db.collection("games").doc(gameId).get();
            const data = doc.data();
            const matched = data.matchedIndices || [];

            const flipped = [...data.flipped];
            const val1 = cards[selectedThiefIndex];

            // é¸ã‚“ã ã‚«ãƒ¼ãƒ‰ãŒã¾ã flippedã«å…¥ã£ã¦ãªã‘ã‚Œã°è¿½åŠ 
            if (!flipped.includes(selectedThiefIndex)) {
                flipped.push(selectedThiefIndex);
            }

            // ä¸€è‡´ã™ã‚‹ support ã‚’æ¢ã™
            const supportIndices = cards
                .map((val, idx) => ({ val, idx }))
                .filter(obj =>
                    obj.val === val1 &&
                    !flipped.includes(obj.idx) &&
                    !matched.includes(obj.idx)
                )
                .slice(0, 1);

            flipped.push(...supportIndices.map(obj => obj.idx));
            isProcessing = false;
            try {
                await db.collection("games").doc(gameId).update({
                    flipped: flipped,
                });
            } catch (error) {
                console.error("Firestore æ›´æ–°ã‚¨ãƒ©ãƒ¼:", error);
            }
        }
        async function specialEffect() {
            const doc = await db.collection("games").doc(gameId).get();
            let data = doc.data();
            const matched = [...(data.matchedIndices || []), ...data.flipped,];
            const flipped = [...data.flipped];
            const val1 = cards[selectedspecialIndex];
            const totalCards = data.cards.length;
            const specialHiddenCards = cards
                .map((val, idx) => ({ val, idx })) // val: ã‚«ãƒ¼ãƒ‰ã®ç¨®é¡, idx: ä½ç½®
                .filter(obj =>
                    specialTypes.includes(obj.val) &&
                    !data.flipped.includes(obj.idx) && // è¡¨ã«ãªã£ã¦ã„ãªã„
                    !(data.matchedIndices || []).includes(obj.idx) // ã™ã§ã«ãƒšã‚¢ã«ãªã£ã¦ã„ãªã„
                );
            specialTypes.forEach(type => {
                const hasUnflippedUnmatchedCard = cards.some((val, idx) =>
                    val === type &&
                    !data.flipped.includes(idx) &&
                    !(data.matchedIndices || []).includes(idx)
                );
                if (hasUnflippedUnmatchedCard) {
                    cardImages[type] = "karaage.png";
                }
            });
            await db.collection("games").doc(gameId).update({
                cardImages: cardImages
            }, { merge: true });
            if (!flipped.includes(selectedspecialIndex)) {
                flipped.push(selectedspecialIndex);
            }
            const isSpecialCardSelected = specialHiddenCards.some(obj => obj.val === val1);
            if (isSpecialCardSelected) {
                const supportIndices = cards
                    .map((val, idx) => ({ val, idx }))
                    .filter(obj =>
                        obj.val === val1 &&
                        !flipped.includes(obj.idx) &&
                        !matched.includes(obj.idx)
                    )
                    .slice(0, 1);
                flipped.push(...supportIndices.map(obj => obj.idx));
                const pairIndex = supportIndices[0].idx;
                const newmatched = [...(data.matchedIndices || []), ...data.flipped, pairIndex];
                scores[currentPlayer] = +2;
                await db.collection("games").doc(gameId).update({
                    matchedIndices: newmatched,
                    flipped: [],
                    scores: scores,
                });

                if (newmatched.length === totalCards) {
                    isProcessing = false;
                    isKaraageMode = false;
                    const updates = {};
                    specialTypes.forEach(type => {
                        if (cardImages[type] === "karaage.png") {
                            updates[`cardImages.${type}`] = `${type}.png`;  // ãƒã‚¹ãƒˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æŒ‡å®š
                        }
                    });

                    await db.collection("games").doc(gameId).update(updates);
                    finishkaraage2Effect();
                    await checkGameOver()
                    return; // â˜…â˜…â˜… é–¢æ•°ã‚’çµ‚äº† â˜…â˜…â˜…
                }

                isProcessing = false;
                isKaraageMode = true;
                await new Promise(resolve => {
                    resolveThiefSelect = resolve;
                });
                karaageeEffect();
                await specialEffect();

            } else {
                flipped.pop();
                const updates = {};
                specialTypes.forEach(type => {
                    if (cardImages[type] === "karaage.png") {
                        updates[`cardImages.${type}`] = `${type}.png`;  // ãƒã‚¹ãƒˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æŒ‡å®š
                    }
                });
                await db.collection("games").doc(gameId).update(updates);
                // 1ç§’å¾…ã¤ï¼ˆ1000ãƒŸãƒªç§’ï¼‰
                finishkaraage2Effect();
                await new Promise(resolve => setTimeout(resolve, 1000));
                const nextPlayer = await getNextPlayer(currentPlayer, numPlayers, data, gameId);
                await db.collection("games").doc(gameId).update({
                    flipped: flipped,
                }, { merge: true });

                isProcessing = false;
                isKaraageMode = false;

            }
        }




        async function triggerCardEffect(card1, data, index) {
            const totalCards = data.cards.length;
            const matched = data.matchedIndices || [];
            const unflippedCards = data.cards.filter((card, index) =>
                !matched.includes(index) && !data.flipped.includes(index)
            );
            await db.collection("games").doc(gameId).update({
                latestEffect: {
                    cardType: card1,
                    timestamp: Date.now()
                }
            });
            switch (card1) {
                case "heart":
                    scores[currentPlayer]++;
                    break;
                case "crowbar":
                    scores[currentPlayer]++;
                    break;
                case "diamond":
                    scores[currentPlayer]++;
                    break;
                case "spade":
                    scores[currentPlayer]++;
                    break;

                case "1":
                    scores[currentPlayer]++;
                    break;
                case "2":
                    scores[currentPlayer] += 2;
                    break;
                case "3":
                    scores[currentPlayer] += 3;
                    break;
                case "angel":
                    scores[currentPlayer] += 5;
                    break;
                case "devil": {
                    const random = Math.random(); // 0ã€œ1ã®ãƒ©ãƒ³ãƒ€ãƒ ãªæ•°

                    if (random < 0.10) {
                        // 10% å…¨å“¡ã®ã‚¹ã‚³ã‚¢ã‚’ 0 ã«ã™ã‚‹
                        for (let player = 1; player <= numPlayers; player++) {
                            scores[player] = 0;
                        }
                        await db.collection("games").doc(gameId).update({
                            scores: scores
                        });

                    } else if (random < 0.20) {
                        // 10% è‡ªåˆ†ã®ã‚¹ã‚³ã‚¢ã‚’ 0 ã«ã™ã‚‹
                        scores[currentPlayer] = 0;
                        await db.collection("games").doc(gameId).update({
                            scores: scores
                        });

                    } else if (random < 0.60) {
                        // 40% è‡ªåˆ†ã®ã‚¹ã‚³ã‚¢ã‚’ -4ï¼ˆæœ€ä½0ï¼‰
                        scores[currentPlayer] = Math.max(0, scores[currentPlayer] - 4);
                        await db.collection("games").doc(gameId).update({
                            scores: scores
                        });

                    } else if (random < 0.99) {
                        // ğŸ’¤ 40% ä¸€å›ä¼‘ã¿
                        await db.collection("games").doc(gameId).update({
                            skippedPlayers: firebase.firestore.FieldValue.arrayUnion(currentPlayer)
                        });
                    }
                    else {
                        windevilEffect();
                        scores[currentPlayer] += 90;
                        await db.collection("games").doc(gameId).update({
                            scores: scores
                        });
                    }

                    break;
                }

                case "revo": {
                    const random = Math.random();
                    if (random < 0.6) {
                        // 30%ã®ç¢ºç‡ã§è‡ªåˆ†ã®ã‚¹ã‚³ã‚¢ã‚’ -3
                        frevoEffect();
                        scores[currentPlayer] = Math.max(0, scores[currentPlayer] - 2);
                        await db.collection("games").doc(gameId).update({
                            scores: scores
                        });
                        break;
                    } else {
                        // 70%ã®ç¢ºç‡ã§å…¨å“¡ã®ã‚¹ã‚³ã‚¢ã‚’å‡ç­‰ã«ã™ã‚‹
                        const totalPlayers = Object.keys(scores).length;
                        const totalScore = Object.values(scores).reduce((a, b) => a + b, 0);
                        const equalScore = Math.floor(totalScore / totalPlayers);
                        for (let player in scores) {
                            scores[player] = equalScore;
                        }
                        scores[currentPlayer] += 3;
                    }
                    break;
                }
                case "skip":
                    scores[currentPlayer] += 2;
                    await db.collection("games").doc(gameId).update({
                        extraTurnAfterMiss: currentPlayer,
                        scores: scores
                    });
                    break;

                case "thief":
                    // æ³¥æ£’ãƒ¢ãƒ¼ãƒ‰é–‹å§‹
                    // æ®‹ã‚Šã‚«ãƒ¼ãƒ‰ãŒ2æšãªã‚‰ã€isThiefMode ã¨ isKaraageMode ã‚’ false ã«ã—ã¦å‡¦ç†ã‚’ã—ãªã„
                    if (unflippedCards.length === 0) {
                        scores[currentPlayer] += 2;
                        break;
                    }
                    else {
                        isProcessing = false;
                        isThiefMode = true;

                        // ã‚«ãƒ¼ãƒ‰ãŒé¸ã°ã‚Œã‚‹ã®ã‚’å¾…ã¤
                        await new Promise(resolve => {
                            resolveThiefSelect = resolve;
                        });
                        // â†“ã‚«ãƒ¼ãƒ‰é¸æŠå¾Œã®å‡¦ç†
                        isThiefMode = false;
                        await thiefEffect(index);
                        scores[currentPlayer] += 2;
                        break;
                    }

                case "king": {
                    const random = Math.random();
                    let currentPlayerScore = scores[currentPlayer];
                    if (random < 0.3) {
                        fkingEffect();
                        scores[currentPlayer] = 0;
                        await db.collection("games").doc(gameId).update({
                            scores: scores
                        });
                        break;
                    } else {
                        // ä»–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ã‚³ã‚¢ã‚’åŠ ç®—ã—ã€ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä»¥å¤–ã®ã‚¹ã‚³ã‚¢ã‚’ã‚¼ãƒ­ã«ã™ã‚‹
                        for (let playerNum = 1; playerNum <= numPlayers; playerNum++) {
                            if (playerNum !== currentPlayer) {
                                const stolen = Math.floor(scores[playerNum] / 2.3); // åˆ‡ã‚Šæ¨ã¦ã§åŠåˆ†
                                scores[playerNum] -= stolen; // ç›¸æ‰‹ã®ã‚¹ã‚³ã‚¢ã‹ã‚‰å¥ªã†
                                currentPlayerScore += stolen; // å¥ªã£ãŸã‚¹ã‚³ã‚¢ã‚’è‡ªåˆ†ã«åŠ ç®—
                            }
                        }
                        // ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ã‚³ã‚¢ã‚’æ›´æ–°
                        scores[currentPlayer] = currentPlayerScore;
                    }
                    break;
                }

                case "special":
                    // æ®‹ã‚Šã‚«ãƒ¼ãƒ‰ãŒ2æšãªã‚‰ã€isThiefMode ã¨ isKaraageMode ã‚’ false ã«ã—ã¦å‡¦ç†ã‚’ã—ãªã„
                    if (unflippedCards.length === 0) {
                        scores[currentPlayer] += 3;
                        break;
                    } else {
                        isProcessing = false;
                        isKaraageMode = true;
                        scores[currentPlayer] += 3;
                        await db.collection("games").doc(gameId).update({ scores });
                        // ã‚«ãƒ¼ãƒ‰ãŒé¸ã°ã‚Œã‚‹ã®ã‚’å¾…ã¤
                        await new Promise(resolve => {
                            resolveThiefSelect = resolve;
                        });
                        isKaraageMode = false;
                        // â†“ã‚«ãƒ¼ãƒ‰é¸æŠå¾Œã®å‡¦ç†
                        await specialEffect(index);
                        break;
                    }
                    isProcessing = false;
                    isKaraageMode = true;
                    scores[currentPlayer] += 2;
                    await db.collection("games").doc(gameId).update({ scores });
                    // ã‚«ãƒ¼ãƒ‰ãŒé¸ã°ã‚Œã‚‹ã®ã‚’å¾…ã¤
                    await new Promise(resolve => {
                        resolveThiefSelect = resolve;
                    });
                    isKaraageMode = false;
                    // â†“ã‚«ãƒ¼ãƒ‰é¸æŠå¾Œã®å‡¦ç†
                    await specialEffect(index);

                    break;
                case "elf":
                    scores[currentPlayer] += 2;
                    shuffleRemainingCardsOnly(data.cards, data.matchedIndices, data.flipped, false);
                    await db.collection("games").doc(gameId).update({
                        cards: data.cards,
                        scores: scores,
                    });
                    break;
                case "tunami": {
                    const penalties = [0, 1, 2, 3, 4, 5, 90];
                    const weights = [8, 17, 25, 25, 16, 8, 1];

                    for (let player in scores) {
                        const penalty = weightedRandom(penalties, weights);
                        scores[player] = Math.max(0, scores[player] - penalty);
                    }

                    await db.collection("games").doc(gameId).update({
                        scores: scores
                    });

                    break;
                }
                case "quake": {
                    scores[currentPlayer] += 2;
                    // ãƒšã‚¢å€™è£œã®ãƒãƒƒãƒ—ä½œæˆï¼ˆã‚«ãƒ¼ãƒ‰ã®ç¨®é¡ã”ã¨ã«ã¾ã¨ã‚ã‚‹ï¼‰
                    const faceDownIndices = data.cards
                        .map((val, idx) => ({ val, idx }))
                        .filter(({ idx }) =>
                            !data.flipped.includes(idx) &&
                            !matched.includes(idx)
                        );

                    // ã‚«ãƒ¼ãƒ‰ã®ç¨®é¡ã”ã¨ã«åˆ†é¡
                    const valueMap = {};
                    faceDownIndices.forEach(({ val, idx }) => {
                        if (!valueMap[val]) valueMap[val] = [];
                        valueMap[val].push(idx);
                    });

                    const usedIndices = new Set();
                    const nonOverlappingPairs = [];

                    for (const val in valueMap) {
                        const indices = valueMap[val].filter(idx => !usedIndices.has(idx));

                        // 2æšå˜ä½ã§ãƒšã‚¢ã«ã™ã‚‹
                        for (let i = 0; i + 1 < indices.length; i += 2) {
                            const pair = [indices[i], indices[i + 1]];
                            nonOverlappingPairs.push(pair);
                            usedIndices.add(indices[i]);
                            usedIndices.add(indices[i + 1]);
                        }
                    }

                    if (nonOverlappingPairs.length === 0) return; // ãƒšã‚¢ãŒãªã‘ã‚Œã°çµ‚äº†

                    // ãƒ©ãƒ³ãƒ€ãƒ ãªãƒšã‚¢ã‚’1çµ„é¸æŠ
                    // 1ã€œ5ã®é‡ã¿ä»˜ããƒšã‚¢æ•°ã‚’æ±ºå®š
                    const pairCounts = [0, 1, 2, 3, 4, 5];
                    const weights = [5, 20, 30, 30, 10, 5];
                    const pairCount = Math.min(nonOverlappingPairs.length, weightedRandom(pairCounts, weights));

                    // ãƒ©ãƒ³ãƒ€ãƒ ã«ãƒšã‚¢ã‚’é¸æŠ
                    const selectedPairs = [];
                    const pairsCopy = [...nonOverlappingPairs]; // å…ƒã®ãƒšã‚¢é…åˆ—ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ã‚·ãƒ£ãƒƒãƒ•ãƒ«ãƒ»æŠ½å‡ºç”¨ã«ä½¿ç”¨
                    const maxSelectablePairs = Math.min(pairCount, pairsCopy.length);
                    for (let i = 0; i < maxSelectablePairs; i++) {
                        const index = Math.floor(Math.random() * pairsCopy.length);
                        selectedPairs.push(pairsCopy.splice(index, 1)[0]); // ãƒ©ãƒ³ãƒ€ãƒ ã«1çµ„å–ã‚Šå‡ºã—ã¦é¸æŠ
                    }

                    // é¸ã°ã‚ŒãŸã‚«ãƒ¼ãƒ‰ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’flattenã—ã€flippedã«è¿½åŠ 
                    const newFlipped = selectedPairs.flat();
                    const updatedFlipped = [...data.flipped, ...newFlipped];

                    // é‡è¤‡ã‚’å–ã‚Šé™¤ãï¼ˆã™ã§ã«flippedã«å…¥ã£ã¦ã„ã‚‹ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚‹å ´åˆï¼‰
                    const uniqueFlipped = [...new Set(updatedFlipped)];

                    // Firebaseãªã©ã«ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã™ã‚‹éš›ã¯ã“ã® uniqueFlipped ã‚’ä½¿ç”¨
                    await db.collection("games").doc(gameId).update({
                        flipped: uniqueFlipped,
                        scores: scores,
                    });

                    break;
                }


            }
            function weightedRandom(penalties, weights) {
                const totalWeight = weights.reduce((sum, w) => sum + w, 0);
                let rand = Math.random() * totalWeight;
                for (let i = 0; i < penalties.length; i++) {
                    rand -= weights[i];
                    if (rand <= 0) return penalties[i];
                }
            }
        }
        function EFFECT() {
            db.collection("games").doc(gameId).onSnapshot((doc) => {
                const data = doc.data();
                const effect = data.latestEffect;
                if (!effect) return;
                const effectKey = effect.cardType + "_" + effect.timestamp;
                if (effect && effectKey !== lastSeenEffectKey) {
                    lastSeenEffectKey = effectKey;
                    showCardEffect(effect.cardType);
                }
            });

        }
        function SpecialEffects() {
            db.collection("games").doc(gameId)
                .onSnapshot((doc) => {
                    const data = doc.data();
                    const effect = data.Effect;

                    if (effect && effect.timestamp !== lastEffectTimestamp) {
                        lastEffectTimestamp = effect.timestamp;

                        // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ç”»é¢ã«è¡¨ç¤º
                        showEffectModal(effect.image, effect.text);
                    }
                });

        }
        async function fkingEffect() {
            await db.collection("games").doc(gameId).update({
                Effect: {
                    type: "fking",
                    text: "ä½™ã¯çŸ¥ã‚‰ãªã„ã€‚çŸ¥ã‚‰ãªã„ã®ã˜ã‚ƒ",
                    image: "fking.png",
                    timestamp: Date.now()
                }
            });
        }
        async function frevoEffect() {
            await db.collection("games").doc(gameId).update({
                Effect: {
                    type: "frevo",
                    text: "ã«ã’ã‚ã‰ï½å¤±æ•—ã ",
                    image: "frevo.png",
                    timestamp: Date.now()
                }
            });
        }
        async function elfEffect() {
            await db.collection("games").doc(gameId).update({
                Effect: {
                    type: "elf",
                    text: "ã‹ã‚ã„ãï½å›ãŸã¡â€¦æ®‹å¿µã™ãã¦ï½—ï½—",
                    image: "elf.png",
                    timestamp: Date.now()
                }
            });
        }
        async function devilEffect() {
            await db.collection("games").doc(gameId).update({
                Effect: {
                    type: "devil",
                    text: "ã¾ã ã™ã‚„ã™ã‚„å¯ã¨ã‘",
                    image: "devil.png",
                    timestamp: Date.now()
                }
            });
        }
        async function windevilEffect() {
            await db.collection("games").doc(gameId).update({
                Effect: {
                    type: "devil",
                    text: "ãã‚Œã¦ã‚„ã‚‹è²¡å®ã ",
                    image: "devil.png",
                    timestamp: Date.now()
                }
            });
        }

        async function skipEffect() {
            await db.collection("games").doc(gameId).update({
                Effect: {
                    type: "skip",
                    text: "ã‚‚ã†ä¸€å›ï¼ã°ã¡ã“ã‚Šã˜ã‚ƒï¼",
                    image: "skip.png",
                    timestamp: Date.now()
                }
            });
        }

        async function karaageeEffect() {
            await db.collection("games").doc(gameId).update({
                Effect: {
                    type: "karaage",
                    text: "ã¾ã ã¾ã ãŠè…¹ã™ã„ã¡ã‚ƒã£ã¦ã‚‹ã…ã…",
                    image: "karaage.png",
                    timestamp: Date.now()
                }
            });
        }


        async function finishkaraage2Effect() {
            await db.collection("games").doc(gameId).update({
                Effect: {
                    type: "finishKaraage",
                    text: "å¤§å¤§å¤§æº€è¶³ï¼ï¼",
                    image: "karaage.png",
                    timestamp: Date.now()
                }
            });
        }

        function showEffectModal(imageSrc, text) {
            const effectImage = document.getElementById("effectImage");
            const effectText = document.getElementById("effectText");
            const modal = document.getElementById("effectModal");

            effectImage.src = imageSrc;
            effectText.innerText = text;

            modal.classList.remove("hidden");
            setTimeout(() => {
                modal.classList.add("hidden");
            }, 2000);
        }

        function showCardEffect(cardType) {
            const effectImage = document.getElementById("effectImage");
            const effectText = document.getElementById("effectText");
            const modal = document.getElementById("effectModal");

            // ç”»åƒã¨èª¬æ˜ã‚’è¨­å®š
            effectImage.src = `${cardType}.png`; // ã‚«ãƒ¼ãƒ‰ç”»åƒãƒ‘ã‚¹ï¼ˆé©å®œä¿®æ­£ï¼‰
            effectText.innerText = getCardEffectText(cardType); // åŠ¹æœèª¬æ˜ï¼ˆâ†“é–¢æ•°ä½œã‚‹ï¼‰

            modal.classList.remove("hidden");
            setTimeout(() => {
                modal.classList.add("hidden");
            }, 2000);
        }

        // åŠ¹æœèª¬æ˜ã‚’ã‚«ãƒ¼ãƒ‰ã®ç¨®é¡ã«å¿œã˜ã¦è¿”ã™
        function getCardEffectText(cardType) {
            switch (cardType) {
                case "bomb":
                    return "ã“ã‚“ãªã¨ã“ã‚ã«çˆ†å¼¾ãŒâ€¦å¾—ç‚¹ãŒã€‚ãŠã¤ã‹ã‚Œ";
                case "heart":
                    return "ä½•ã®å¤‰å“²ã‚‚ãªã„ã‚«ãƒ¼ãƒ‰ã€‚ãŸã ã®ï¼‘ç‚¹ã€‚ã¾ã ã¾ã ï¼";
                case "diamond":
                    return "ä½•ã®å¤‰å“²ã‚‚ãªã„ã‚«ãƒ¼ãƒ‰ã€‚ãŸã ã®ï¼‘ç‚¹ã€‚æˆé•·æœŸã ";
                case "spade":
                    return "ä½•ã®å¤‰å“²ã‚‚ãªã„ã‚«ãƒ¼ãƒ‰ã€‚ãŸã ã®ï¼‘ç‚¹ã€‚ã“ã‚Œã‹ã‚‰ã ";
                case "special":
                    return "é›‘é­šã®ã‚«ãƒ¼ãƒ‰ãŒã€ã‹ã‚‰ã‚ã’å‘³ã«ï¼ï¼Ÿé£Ÿã¹ã¤ãã›";
                case "crowbar":
                    return "ä½•ã®å¤‰å“²ã‚‚ãªã„ã‚«ãƒ¼ãƒ‰ã€‚ã¾ã ã•ãªãã ";
                case "1":
                    return "ã‚³ãƒ„ã‚³ãƒ„1ç‚¹ï¼";
                case "2":
                    return "2ç‚¹ã‚‚ï¼ï¼Ÿæœ‰é›£ãé ‚æˆ´";
                case "3":
                    return "ã“ã‚Œã¯ãƒ¬ã‚¢ã ã€‚ã“ã®é‹å‘½ã«ä¹¾æ¯ï¼";
                case "angel":
                    return "å¤©ä½¿ãŒåƒ•ã®ä¸‹ã«â€¦ï¼Ÿã‹ã‚ã„ã„â€¦";
                case "devil":
                    return "ã¨ã…ã€‚æ‚ªé­”å‚ä¸Šã ï¼ã‚„ã£ã±æ‚ªã•æœ€é«˜ã ãœã‡ã‡";
                case "skip":
                    return "å¤§ä¸ˆå¤«ã€‚ã¾ã æˆ¦ãˆã‚‹ã‚ˆã€‚";
                case "revo":
                    return "é©å‘½ã®ç«ã‚’ã‚ã’ã‚ã‰ã‰ã‰ã€‚å¼±è€…ã«æ•‘ã„ã‚’";
                case "king":
                    return "å¾ãŒç‹ã ã€‚çš†ã®è€…ã™ã¹ã¦ã‚ˆã“ã›";
                case "thief":
                    return "ã©ã‚“ãªã‚«ãƒ¼ãƒ‰ã§ã‚‚å¥ªã£ã¦ãã¾ã£ã›ã€‚ä»»ã›ã¦ãã ã›ã‡";
                case "elf":
                    return "ã‚«ãƒ¼ãƒ‰åˆ†ã‹ã‚‰ãªããªã£ã¡ã‚ƒã£ãŸã­";
                case "tunami":
                    return "å…¨å“¡æŒã¡ç‰©ã‚’æ¨ã¦ã¦é€ƒã’ã‚â€•â€•";
                case "quake":
                    return "å¤§ãã„æºã‚Œã ï¼æ³¨æ„ã—ã¦ï¼";
            }
        }


        async function updateSP() {
            const gameDoc = await db.collection("games").doc(gameId).get();
            //ç¾åœ¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å¤‰æ›´
            const gameData = gameDoc.data();
            const currentPlayerNum = gameData.currentPlayer;
            const PName = gameData.PName;
            const myplayerName = PName[currentPlayerNum];
            const playerDiv = document.getElementById("currentPlayer");
            playerDiv.innerHTML = `<h3>ç¾åœ¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: ${myplayerName}</h3>`;

            //ã‚¹ã‚³ã‚¢æ›´æ–°
            const scoreBoard = document.getElementById("scores");
            scoreBoard.innerHTML = "";
            for (let i = 1; i <= numPlayers; i++) {
                scoreBoard.innerHTML += `<h3>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${PName[i]} ã‚¹ã‚³ã‚¢: ${scores[i]}</h3>`;
            }
        }
        async function checkGameOver() {
            const gameDoc = await db.collection("games").doc(gameId).get();
            const data = gameDoc.data();

            const totalCards = data.cards.length;
            const matched = data.matchedIndices || [];
            if (matched.length === totalCards) {
                await db.collection("games").doc(gameId).update({
                    gameOver: true
                });
                await showGameOver();
            }
            db.collection("games").doc(gameId)
                .onSnapshot((doc) => {
                    const data = doc.data();
                    if (data?.gameOver) {
                        showGameOver();
                    }
                });
        }

        async function showGameOver() {
            setTimeout(async () => {
                const finalScoreEl = document.getElementById("finalScore");

                const gameDoc = await db.collection("games").doc(gameId).get();
                const data = gameDoc.data();

                // PName ã¨ scores ã‚’å–å¾—
                const PName = data.PName;
                const scores = data.scores;
                // scores ã¨ PName ã‚’ä½¿ã£ã¦ [{name, score}] ã®é…åˆ—ã‚’ä½œã‚‹
                const rankingArray = Object.entries(scores).map(([playerNum, score]) => {
                    const name = PName[playerNum] ?? `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${playerNum}`;
                    return { name, score };
                });

                // ã‚¹ã‚³ã‚¢é™é †ã§ã‚½ãƒ¼ãƒˆ
                rankingArray.sort((a, b) => b.score - a.score);

                // è¡¨ç¤ºç”¨ã®æ–‡å­—åˆ—ã‚’ç”Ÿæˆ
                const rankingList = rankingArray
                    .map((entry, index) => {
                        const style = index === 0 ? 'style="color: red;"' : '';
                        return `<li ${style}>${index + 1}ä½: ${entry.name}ï¼ˆ${entry.score} ç‚¹ï¼‰</li>`;
                    })
                    .join(""); // <li>è¦ç´ ã®æ–‡å­—åˆ—ã‚’çµåˆ

                // æœ€çµ‚çš„ãªãƒªã‚¹ãƒˆã‚’ finalScore ã®è¦ç´ ã«æŒ¿å…¥
                finalScoreEl.innerHTML = `<ul>${rankingList}</ul>`;

                // æ–‡å­—ã‚’å¤§ããã™ã‚‹ã‚¹ã‚¿ã‚¤ãƒ«
                finalScoreEl.style.fontSize = "24px"; // ã‚µã‚¤ã‚ºèª¿æ•´
                finalScoreEl.style.lineHeight = "1.5"; // è¡Œé–“ã®èª¿æ•´
                finalScoreEl.style.listStyleType = "none"; // é»’ç‚¹ã‚’é™¤å»
                finalScoreEl.style.paddingLeft = "20px"; // å·¦ã«ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¿½åŠ ã—ã¦ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ
                finalScoreEl.style.color = "#333"; // æ–‡å­—ã®è‰²ã‚’å¤‰æ›´

                // ul è¦ç´ ã‚’å·¦æƒãˆ
                const ul = finalScoreEl.querySelector('ul');
                ul.style.textAlign = 'left'; // å·¦æƒãˆ
                document.getElementById("gameOverModal").style.display = "flex";
            }, 2000);  // 1000ãƒŸãƒªç§’ï¼ˆ1ç§’ï¼‰å¾Œã«å®Ÿè¡Œ
        }





        async function restartGame() {
            document.getElementById("gameOverModal").style.display = "none";
            document.getElementById("gameBoard").style.display = "none";
            document.querySelector(".score-board").style.display = "none";
            document.querySelector(".current-Player").style.display = "none";
            document.getElementById("gameIdDisplay").style.display = "block"
            document.getElementById("lobbySection").style.display = "block";

            await db.collection("games").doc(gameId).update({
                started: false,
                gameOver: false,
                highlightedIndices: [],
                flipped: [],
                matchedIndices: [],
                scores: [],
                currentPlayer: [],
                PName: [],
                cardImages: cardImages,
                Effect: firebase.firestore.FieldValue.delete(),
                latestEffect: firebase.firestore.FieldValue.delete()
            }, { merge: true });
        }
        async function leaveGame() {
            if (!gameId || !playerId) return;

            const playerRef = db.collection("games").doc(gameId).collection("players").doc(playerId);
            const playerSnap = await playerRef.get();
            const playerData = playerSnap.data();

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‰Šé™¤
            await playerRef.delete();

            // ãƒ›ã‚¹ãƒˆãªã‚‰ã€ä»–ã®èª°ã‹ã‚’ãƒ›ã‚¹ãƒˆã«ã™ã‚‹
            if (playerData?.isHost) {
                const playersSnapshot = await db.collection("games").doc(gameId).collection("players").get();
                if (!playersSnapshot.empty) {
                    const nextHost = playersSnapshot.docs[0];
                    await nextHost.ref.update({ isHost: true });
                }
            }

            // å…¨å“¡ãŒæŠœã‘ãŸã‹ç¢ºèª
            await checkIfGameEmptyAndDelete();
            await updateHostUI();

            // ãƒ­ãƒ“ãƒ¼ç”»é¢ã‹ã‚‰é€€å‡º
            window.location.reload(); // ã¾ãŸã¯ãƒ›ãƒ¼ãƒ ç”»é¢ã«æˆ»ã™å‡¦ç†ãªã©
            window.addEventListener("beforeunload", async () => {
                await leaveGame();
            });
        }
        async function updateHostUI() {
            // ãƒ›ã‚¹ãƒˆãŒå¤‰æ›´ã•ã‚ŒãŸå¾Œã«UIã‚’æ›´æ–°
            await checkIfHost(); // æ–°ã—ã„ãƒ›ã‚¹ãƒˆæƒ…å ±ã‚’ç¢ºèªã—ã¦UIã«åæ˜ 
        }




        async function exitGame() {
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±ã‚’ã™ã¹ã¦å‰Šé™¤
            const playersRef = db.collection("games").doc(gameId).collection("players");
            const playersSnapshot = await playersRef.get();
            const deletePromises = playersSnapshot.docs.map(doc => doc.ref.delete());
            await Promise.all(deletePromises);

            // ã‚²ãƒ¼ãƒ ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‰Šé™¤
            await db.collection("games").doc(gameId).delete();
            location.reload();
        }
        async function checkIfGameEmptyAndDelete() {
            const playersRef = db.collection("games").doc(gameId).collection("players");
            const playersSnapshot = await playersRef.get();

            if (playersSnapshot.empty) {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã„ãªã‘ã‚Œã°ã‚²ãƒ¼ãƒ ã‚’å‰Šé™¤
                await db.collection("games").doc(gameId).delete();
                location.reload();  // ã‚²ãƒ¼ãƒ ãŒå‰Šé™¤ã•ã‚ŒãŸå¾Œã€ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰
            }
        }
        document.getElementById("gameIdInput").addEventListener("keydown", function (event) {
            if (event.key === "Enter") {
                joinGame();
            }
        });

        document.getElementById("playerNameInput").addEventListener("keydown", function (event) {
            if (event.key === "Enter") {
                enterLobby();
            }
        });

    </script>
</body>

</html>
